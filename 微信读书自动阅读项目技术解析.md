# 微信读书自动阅读项目技术解析

## 📚 项目概述

本项目是一个基于**接口逆向分析**的微信读书自动阅读脚本，主要用于在微信读书阅读挑战赛中自动刷阅读时长和保持签到天数。相比于传统的ADB模拟器或阅读器挂机方案，本项目采用纯接口调用的方式，具有轻量化、高效率的特点。

### 🎯 核心功能
- **自动阅读**：模拟真实用户阅读行为，自动积累阅读时长
- **Cookie自维护**：自动刷新登录状态，无需人工干预
- **多平台部署**：支持GitHub Actions、Docker、本地运行多种部署方式
- **消息推送**：支持PushPlus、WxPusher、Telegram三种推送方式
- **智能随机化**：随机选择书籍、章节，增加操作真实性

## 🔧 技术架构

### 项目结构
```
wxread/
├── main.py           # 主逻辑文件，核心自动阅读逻辑
├── config.py         # 配置文件，存储各种参数设置
├── push.py           # 推送模块，多渠道消息推送
├── Dockerfile        # Docker容器配置
├── .github/workflows/
│   └── deploy.yml    # GitHub Actions工作流配置
└── README.md         # 项目说明文档
```

### 技术栈
- **Python 3.10**：主要开发语言
- **requests**：HTTP请求库，用于接口调用
- **hashlib**：哈希算法库，用于生成签名
- **urllib**：URL处理库，用于数据编码
- **Docker**：容器化部署
- **GitHub Actions**：自动化CI/CD

## 🛠️ 核心技术实现

### 1. 接口逆向分析

#### 关键接口
- **阅读接口**：`https://weread.qq.com/web/book/read`
- **Cookie刷新**：`https://weread.qq.com/web/login/renewal`
- **Synckey修复**：`https://weread.qq.com/web/book/chapterInfos`

#### 请求参数结构
```python
data = {
    "appId": "wb182564874603h266381671",  # 应用标识
    "b": "书籍ID",                        # 动态替换
    "c": "章节ID",                        # 动态替换
    "ci": 27,                            # 章节索引
    "co": 389,                           # 内容位置
    "sm": "内容摘要",                     # 阅读内容摘要
    "pr": 74,                            # 页码进度
    "rt": 15,                            # 阅读时长
    "ts": 1744264311434,                 # 毫秒时间戳
    "rn": 466,                           # 随机数
    "sg": "安全签名",                     # SHA256签名
    "ct": 1744264311,                    # 秒级时间戳
    "ps": "用户标识",                     # 用户唯一标识
    "pc": "设备标识",                     # 设备唯一标识
    "s": "校验和"                        # 请求校验和
}
```

### 2. 加密算法实现

#### 安全签名生成
```python
def cal_hash(input_string):
    """
    微信读书特有的哈希算法，通过JS逆向获得
    使用双重哈希值计算，增强安全性
    """
    _7032f5 = 0x15051505  # 初始哈希值1
    _cc1055 = _7032f5     # 初始哈希值2
    length = len(input_string)
    _19094e = length - 1
    
    # 逆向处理字符串
    while _19094e > 0:
        _7032f5 = 0x7fffffff & (_7032f5 ^ ord(input_string[_19094e]) << (length - _19094e) % 30)
        _cc1055 = 0x7fffffff & (_cc1055 ^ ord(input_string[_19094e - 1]) << _19094e % 30)
        _19094e -= 2
    
    return hex(_7032f5 + _cc1055)[2:].lower()
```

#### SHA256签名
```python
# 使用逆向获得的密钥生成安全签名
KEY = "3c5c8717f3daf09iop3423zafeqoi"
data['sg'] = hashlib.sha256(f"{data['ts']}{data['rn']}{KEY}".encode()).hexdigest()
```

### 3. Cookie自动维护机制

#### 获取新密钥
```python
def get_wr_skey():
    """获取新的wr_skey值，保持登录状态"""
    response = requests.post(RENEW_URL, headers=headers, cookies=cookies,
                             data=json.dumps(COOKIE_DATA, separators=(',', ':')))
    
    # 从响应头提取新的wr_skey
    for cookie in response.headers.get('Set-Cookie', '').split(';'):
        if "wr_skey" in cookie:
            return cookie.split('=')[-1][:8]
    return None
```

#### 智能刷新策略
- **预防性刷新**：程序启动时主动刷新Cookie
- **失败重试**：请求失败时自动尝试刷新Cookie
- **错误处理**：刷新失败时推送通知并终止程序

### 4. 智能随机化策略

#### 书籍章节随机选择
```python
# 预定义书籍和章节池
book = ["36d322f07186022636daa5e", "6f932ec05dd9eb6f96f14b9", ...]
chapter = ["ecc32f3013eccbc87e4b62e", "a87322c014a87ff679a21ea", ...]

# 每次请求随机选择
data['b'] = random.choice(book)
data['c'] = random.choice(chapter)
```

#### 时间参数随机化
```python
data['ts'] = int(thisTime * 1000) + random.randint(0, 1000)  # 毫秒级随机
data['rn'] = random.randint(0, 1000)                         # 随机数字
time.sleep(30)  # 固定30秒间隔，模拟真实阅读
```

## 📱 推送系统设计

### 多渠道推送支持

#### 1. PushPlus推送
```python
def push_pushplus(self, content, token):
    """PushPlus微信推送"""
    response = requests.post(
        "https://www.pushplus.plus/send",
        data=json.dumps({
            "token": token,
            "title": "微信阅读推送...",
            "content": content
        }).encode('utf-8'),
        headers=self.headers,
        timeout=10
    )
```

#### 2. Telegram推送
```python
def push_telegram(self, content, bot_token, chat_id):
    """Telegram推送，支持代理和直连"""
    url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
    payload = {"chat_id": chat_id, "text": content}
    
    # 先尝试代理，失败后直连
    try:
        response = requests.post(url, json=payload, proxies=self.proxies, timeout=30)
    except:
        response = requests.post(url, json=payload, timeout=30)
```

#### 3. WxPusher推送
```python
def push_wxpusher(self, content, spt):
    """WxPusher极简推送"""
    url = f"https://wxpusher.zjiecode.com/api/send/message/{spt}/{content}"
    response = requests.get(url, timeout=10)
```

### 重试机制
- **最大重试次数**：5次
- **重试间隔**：随机3-6分钟
- **失败处理**：记录详细错误日志

## 🚀 部署方案

### 1. GitHub Actions部署

#### 工作流配置
```yaml
name: wxread

on:
  schedule:
    - cron: '0 17 * * *'  # 北京时间每天01:00
  workflow_dispatch:        # 支持手动触发

jobs:
  deploy:
    runs-on: ubuntu-22.04
    environment: AutoRead
    
    steps:
    - name: Set DNS to Google's DNS
      run: |
        echo "nameserver 8.8.8.8" | sudo tee /etc/resolv.conf
        
    - name: Checkout repository
      uses: actions/checkout@v2
      
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.10'
        
    - name: Install dependencies
      run: |
        pip install requests==2.32.3 urllib3==2.2.3
        
    - name: Run deployment script
      env:
        WXREAD_CURL_BASH: ${{ secrets.WXREAD_CURL_BASH }}
        PUSH_METHOD: ${{ secrets.PUSH_METHOD }}
        READ_NUM: ${{ vars.READ_NUM }}
      run: python main.py
```

#### 环境变量配置

| 变量名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| `WXREAD_CURL_BASH` | secrets | ✅ | 抓包获得的curl命令 |
| `READ_NUM` | variables | ❌ | 阅读次数，默认40次 |
| `PUSH_METHOD` | secrets | ❌ | 推送方式：pushplus/wxpusher/telegram |
| `PUSHPLUS_TOKEN` | secrets | 条件 | PushPlus token |
| `WXPUSHER_SPT` | secrets | 条件 | WxPusher token |
| `TELEGRAM_BOT_TOKEN` | secrets | 条件 | Telegram bot token |
| `TELEGRAM_CHAT_ID` | secrets | 条件 | Telegram chat id |

### 2. Docker部署

#### Dockerfile分析
```dockerfile
FROM python:3.10-slim

WORKDIR /app

# 设置中国时区
ENV TZ=Asia/Shanghai
RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime

# 安装cron定时任务
RUN apt-get update && apt-get install -y cron

# 复制项目文件
COPY main.py push.py config.py ./

# 安装Python依赖
RUN pip install --no-cache-dir requests>=2.32.3 urllib3>=2.2.3

# 创建定时任务（每天凌晨1点）
RUN echo "0 1 * * * cd /app && python3 main.py >> /app/logs/$(date +%Y-%m-%d).log 2>&1" > /etc/cron.d/wxread-cron

# 启动cron服务
CMD ["sh", "-c", "service cron start && tail -f /dev/null"]
```

#### 部署命令
```bash
# 构建并运行容器
docker rm -f wxread && \
docker build -t wxread . && \
docker run -d --name wxread \
  -v $(pwd)/logs:/app/logs \
  --restart always wxread

# 测试运行
docker exec -it wxread python /app/main.py
```

### 3. 本地部署

#### 环境要求
- Python 3.10+
- requests 2.32.3+
- urllib3 2.2.3+

#### 配置步骤
1. **克隆项目**：`git clone https://github.com/findmover/wxread.git`
2. **配置参数**：修改`config.py`中的headers、cookies等参数
3. **安装依赖**：`pip install -r requirements.txt`
4. **运行脚本**：`python main.py`

## 🔍 抓包配置指南

### 1. 获取请求数据

#### 抓包步骤
1. 访问[微信读书官网](https://weread.qq.com/)
2. 搜索并打开【三体】
3. 点击阅读，然后点击下一页
4. 使用浏览器开发者工具抓取`read`接口
5. 右键复制为cURL(bash)格式

#### 预期响应格式
```json
{
  "succ": 1,
  "synckey": 564589834
}
```

### 2. 数据转换

#### 方法一：在线转换
使用[curlconverter.com](https://curlconverter.com/python/)将curl命令转换为Python格式

#### 方法二：手动提取
```python
# 从curl命令中提取headers和cookies
headers = {
    'accept': 'application/json, text/plain, */*',
    'user-agent': 'Mozilla/5.0 ...',
    # ... 其他headers
}

cookies = {
    'wr_skey': 'xxxxxxxx',
    'wr_vid': 'xxxxxxxx',
    # ... 其他cookies
}
```

## ⚡ 性能优化

### 1. 请求优化
- **连接复用**：使用requests.Session()复用TCP连接
- **超时设置**：设置合理的请求超时时间
- **重试机制**：失败请求自动重试

### 2. 内存优化
- **及时清理**：及时释放不需要的变量
- **流式处理**：大数据量时使用流式处理
- **缓存策略**：合理使用缓存减少重复计算

### 3. 并发处理
- **异步IO**：使用asyncio提升并发性能
- **线程池**：CPU密集型任务使用线程池
- **进程池**：IO密集型任务使用进程池

## 🛡️ 安全考虑

### 1. 敏感信息保护
- **环境变量**：敏感配置使用环境变量存储
- **加密存储**：重要数据加密后存储
- **权限控制**：最小权限原则

### 2. 反检测机制
- **随机化**：请求参数随机化
- **间隔控制**：合理控制请求间隔
- **User-Agent轮换**：定期更换User-Agent

### 3. 错误处理
- **异常捕获**：全面的异常处理机制
- **日志记录**：详细的操作日志
- **监控告警**：异常情况及时告警

## 📊 监控与日志

### 1. 日志系统
```python
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)-8s - %(message)s'
)
```

### 2. 关键指标监控
- **成功率**：阅读请求成功率
- **响应时间**：接口响应时间
- **错误类型**：详细的错误分类统计

### 3. 告警机制
- **失败告警**：连续失败时推送告警
- **状态报告**：每日运行状态推送
- **异常检测**：异常行为自动检测

## 🔧 故障排查

### 常见问题及解决方案

#### 1. Cookie过期
**现象**：请求返回认证失败
**解决**：重新抓包获取新的Cookie

#### 2. 签名验证失败
**现象**：请求返回签名错误
**解决**：检查时间戳和随机数生成逻辑

#### 3. Synckey缺失
**现象**：响应中缺少synckey字段
**解决**：调用章节信息接口修复

#### 4. 推送失败
**现象**：推送消息发送失败
**解决**：检查token配置和网络连接

## 📈 扩展功能

### 1. 数据统计
- **阅读时长统计**：记录每日阅读时长
- **成功率分析**：分析请求成功率趋势
- **性能监控**：监控脚本运行性能

### 2. 智能调度
- **动态间隔**：根据成功率动态调整请求间隔
- **自适应重试**：智能重试策略
- **负载均衡**：多账号负载均衡

### 3. 用户界面
- **Web界面**：提供Web管理界面
- **移动端App**：开发移动端管理应用
- **API接口**：提供RESTful API

## 🎯 总结

本项目通过深度的接口逆向分析，实现了一个高效、稳定的微信读书自动阅读方案。相比传统的模拟器方案，具有以下优势：

1. **轻量化**：纯接口调用，资源消耗低
2. **稳定性**：自动维护登录状态，容错性强
3. **灵活性**：支持多种部署方式，适应性广
4. **智能化**：随机化策略，降低检测风险
5. **可扩展**：模块化设计，易于功能扩展

通过合理的配置和部署，本项目可以有效帮助用户自动完成微信读书的阅读任务，提升用户体验。

---

**注意**：本项目仅供学习交流使用，请遵守相关平台的使用条款，合理使用自动化工具。 