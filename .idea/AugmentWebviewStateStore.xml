<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="AugmentWebviewStateStore">
    <option name="stateMap">
      <map>
        <entry key="CHAT_STATE" value="{&quot;currentConversationId&quot;:&quot;c44c81ce-23c0-4cb1-93cd-e6ad60e9c1ee&quot;,&quot;conversations&quot;:{&quot;c44c81ce-23c0-4cb1-93cd-e6ad60e9c1ee&quot;:{&quot;id&quot;:&quot;c44c81ce-23c0-4cb1-93cd-e6ad60e9c1ee&quot;,&quot;createdAtIso&quot;:&quot;2025-07-09T16:01:54.359Z&quot;,&quot;lastInteractedAtIso&quot;:&quot;2025-07-09T16:14:27.490Z&quot;,&quot;chatHistory&quot;:[{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;4d129036-a245-4027-96b1-bbd8aceabd26&quot;,&quot;request_message&quot;:&quot;给所有代码加上注释&quot;,&quot;rich_text_json_repr&quot;:{&quot;type&quot;:&quot;doc&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;paragraph&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;给所有代码加上注释&quot;}]}]},&quot;mentioned_items&quot;:[],&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:0,&quot;content&quot;:&quot;以下是为`main.py`添加详细注释的版本：\n\n&lt;augment_code_snippet path=\&quot;main.py\&quot; mode=\&quot;EDIT\&quot;&gt;\n```python\n# main.py 主逻辑：包括字段拼接、模拟请求\nimport re\nimport json\nimport time\nimport random\nimport logging\nimport hashlib\nimport requests\nimport urllib.parse\nfrom push import push  # 导入推送模块\nfrom config import data, headers, cookies, READ_NUM, PUSH_METHOD, book, chapter  # 导入配置信息\n\n# 配置日志格式\nlogger = logging.getLogger(__name__)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)-8s - %(message)s')\n\n# 加密盐及其它默认值\nKEY = \&quot;3c5c8717f3daf09iop3423zafeqoi\&quot;  # 用于生成安全签名的密钥\nCOOKIE_DATA = {\&quot;rq\&quot;: \&quot;%2Fweb%2Fbook%2Fread\&quot;}  # 刷新cookie时的请求数据\nREAD_URL = \&quot;https://weread.qq.com/web/book/read\&quot;  # 阅读接口URL\nRENEW_URL = \&quot;https://weread.qq.com/web/login/renewal\&quot;  # 刷新token的URL\nFIX_SYNCKEY_URL = \&quot;https://weread.qq.com/web/book/chapterInfos\&quot;  # 修复synckey的URL\n\n\ndef encode_data(data):\n    \&quot;\&quot;\&quot;数据编码：将字典转换为URL编码的字符串，并按键名排序\&quot;\&quot;\&quot;\n    return '&amp;'.join(f\&quot;{k}={urllib.parse.quote(str(data[k]), safe='')}\&quot; for k in sorted(data.keys()))\n\n\ndef cal_hash(input_string):\n    \&quot;\&quot;\&quot;计算哈希值：使用特定算法计算字符串的哈希值，用于请求校验\&quot;\&quot;\&quot;\n    _7032f5 = 0x15051505  # 初始化第一个哈希值\n    _cc1055 = _7032f5     # 初始化第二个哈希值\n    length = len(input_string)  # 获取输入字符串长度\n    _19094e = length - 1  # 从字符串末尾开始\n\n    # 循环处理字符串中的每对字符\n    while _19094e &gt; 0:\n        # 对第一个哈希值进行位运算\n        _7032f5 = 0x7fffffff &amp; (_7032f5 ^ ord(input_string[_19094e]) &lt;&lt; (length - _19094e) % 30)\n        # 对第二个哈希值进行位运算\n        _cc1055 = 0x7fffffff &amp; (_cc1055 ^ ord(input_string[_19094e - 1]) &lt;&lt; _19094e % 30)\n        _19094e -= 2  # 每次处理两个字符\n\n    # 返回两个哈希值相加后的十六进制表示（去掉0x前缀）\n    return hex(_7032f5 + _cc1055)[2:].lower()\n\ndef get_wr_skey():\n    \&quot;\&quot;\&quot;刷新cookie密钥：获取新的wr_skey值\&quot;\&quot;\&quot;\n    # 发送请求获取新的cookie\n    response = requests.post(RENEW_URL, headers=headers, cookies=cookies,\n                             data=json.dumps(COOKIE_DATA, separators=(',', ':')))\n    # 从响应头中提取wr_skey\n    for cookie in response.headers.get('Set-Cookie', '').split(';'):\n        if \&quot;wr_skey\&quot; in cookie:\n            return cookie.split('=')[-1][:8]  # 返回前8位\n    return None  # 如果没找到则返回None\n\ndef fix_no_synckey():\n    \&quot;\&quot;\&quot;修复synckey缺失问题：通过请求章节信息接口\&quot;\&quot;\&quot;\n    # 发送请求获取章节信息，间接修复synckey\n    requests.post(FIX_SYNCKEY_URL, headers=headers, cookies=cookies,\n                             data=json.dumps({\&quot;bookIds\&quot;:[\&quot;3300060341\&quot;]}, separators=(',', ':')))\n\ndef refresh_cookie():\n    \&quot;\&quot;\&quot;刷新cookie：获取并更新wr_skey\&quot;\&quot;\&quot;\n    logging.info(f\&quot; 刷新cookie\&quot;)\n    new_skey = get_wr_skey()  # 获取新的skey\n    if new_skey:\n        # 更新cookies中的wr_skey\n        cookies['wr_skey'] = new_skey\n        logging.info(f\&quot;✅ 密钥刷新成功，新密钥：{new_skey}\&quot;)\n        logging.info(f\&quot; 重新本次阅读。\&quot;)\n    else:\n        # 获取失败，记录错误并推送通知\n        ERROR_CODE = \&quot;❌ 无法获取新密钥或者WXREAD_CURL_BASH配置有误，终止运行。\&quot;\n        logging.error(ERROR_CODE)\n        push(ERROR_CODE, PUSH_METHOD)  # 推送错误信息\n        raise Exception(ERROR_CODE)  # 抛出异常终止程序\n\n# 主程序开始执行\n\n# 首先刷新cookie确保有效\nrefresh_cookie()\n\n# 初始化计数器和时间\nindex = 1  # 阅读次数计数器\nlastTime = int(time.time()) - 30  # 上次阅读时间（初始为当前时间减30秒）\n\n# 循环执行阅读操作，直到达到设定的次数\nwhile index &lt;= READ_NUM:\n    # 移除旧的校验和\n    data.pop('s')\n    \n    # 随机选择书籍和章节\n    data['b'] = random.choice(book)  # 随机选择一本书\n    data['c'] = random.choice(chapter)  # 随机选择一个章节\n    \n    # 更新时间相关字段\n    thisTime = int(time.time())  # 当前时间戳（秒）\n    data['ct'] = thisTime  # 当前时间\n    data['rt'] = thisTime - lastTime  # 阅读时长\n    data['ts'] = int(thisTime * 1000) + random.randint(0, 1000)  # 毫秒级时间戳加随机数\n    data['rn'] = random.randint(0, 1000)  # 随机数\n    \n    # 生成安全签名\n    data['sg'] = hashlib.sha256(f\&quot;{data['ts']}{data['rn']}{KEY}\&quot;.encode()).hexdigest()\n    \n    # 计算校验和\n    data['s'] = cal_hash(encode_data(data))\n\n    # 记录日志\n    logging.info(f\&quot;⏱️ 尝试第 {index} 次阅读...\&quot;)\n    logging.info(f\&quot; data: {data}\&quot;)\n    \n    # 发送阅读请求\n    response = requests.post(READ_URL, headers=headers, cookies=cookies, data=json.dumps(data, separators=(',', ':')))\n    resData = response.json()  # 解析响应JSON\n    logging.info(f\&quot; response: {resData}\&quot;)\n\n    # 处理响应结果\n    if 'succ' in resData:  # 请求成功\n        if 'synckey' in resData:  # 有同步键，表示阅读成功\n            lastTime = thisTime  # 更新上次阅读时间\n            index += 1  # 计数器加1\n            time.sleep(30)  # 等待30秒\n            logging.info(f\&quot;✅ 阅读成功，阅读进度：{(index - 1) * 0.5} 分钟\&quot;)\n        else:\n            # 没有synckey，尝试修复\n            logging.warning(\&quot;❌ 无synckey, 尝试修复...\&quot;)\n            fix_no_synckey()\n    else:\n        # 请求失败，可能是cookie过期\n        logging.warning(\&quot;❌ cookie 已过期，尝试刷新...\&quot;)\n        refresh_cookie()  # 刷新cookie\n\n# 所有阅读完成\nlogging.info(\&quot; 阅读脚本已完成！\&quot;)\n\n# 如果配置了推送方法，则发送完成通知\nif PUSH_METHOD not in (None, ''):\n    logging.info(\&quot;⏱️ 开始推送...\&quot;)\n    push(f\&quot; 微信读书自动阅读完成！\\n⏱️ 阅读时长：{(index - 1) * 0.5}分钟。\&quot;, PUSH_METHOD)\n```\n&lt;/augment_code_snippet&gt;\n&quot;},{&quot;id&quot;:2,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:3,&quot;type&quot;:3,&quot;content&quot;:&quot;main.py:0-646\nmain.py:646-1215\nmain.py:1215-1763\nmain.py:1763-2165\nmain.py:2165-2947\nmain.py:2947-3496\nDockerfile:0-776\nREADME.md:0-758\nREADME.md:758-1212\nREADME.md:1212-1885\nREADME.md:1885-2639\nREADME.md:2639-3365\nREADME.md:3365-3557\nREADME.md:3557-4309\nREADME.md:4309-4358\nconfig.py:0-583\nconfig.py:583-1047\nconfig.py:1047-1524\nconfig.py:1524-1869\nconfig.py:1869-2324\nconfig.py:2324-2810\nconfig.py:2810-3644\nconfig.py:3644-3881\n.gitignore:0-65\n.github/workflows/deploy.yml:0-310\n.github/workflows/deploy.yml:310-946\n.github/workflows/deploy.yml:946-1425\npush.py:0-734\npush.py:734-1752\npush.py:1752-2589\npush.py:2589-3324\npush.py:3324-3915\n.vscode/settings.json:0-39&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:0,&quot;type&quot;:0,&quot;text_node&quot;:{&quot;content&quot;:&quot;给所有代码加上注释&quot;}},{&quot;id&quot;:1,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;D:/130__Work__Python/wxread&quot;,&quot;folderRoot&quot;:&quot;D:/130__Work__Python/wxread&quot;}],&quot;workspaceFoldersUnchanged&quot;:false}}],&quot;timestamp&quot;:&quot;2025-07-09T16:02:35.702Z&quot;,&quot;response_text&quot;:&quot;以下是为`main.py`添加详细注释的版本：\n\n````python path=main.py mode=EDIT\n# main.py 主逻辑：包括字段拼接、模拟请求\nimport re\nimport json\nimport time\nimport random\nimport logging\nimport hashlib\nimport requests\nimport urllib.parse\nfrom push import push  # 导入推送模块\nfrom config import data, headers, cookies, READ_NUM, PUSH_METHOD, book, chapter  # 导入配置信息\n\n# 配置日志格式\nlogger = logging.getLogger(__name__)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)-8s - %(message)s')\n\n# 加密盐及其它默认值\nKEY = \&quot;3c5c8717f3daf09iop3423zafeqoi\&quot;  # 用于生成安全签名的密钥\nCOOKIE_DATA = {\&quot;rq\&quot;: \&quot;%2Fweb%2Fbook%2Fread\&quot;}  # 刷新cookie时的请求数据\nREAD_URL = \&quot;https://weread.qq.com/web/book/read\&quot;  # 阅读接口URL\nRENEW_URL = \&quot;https://weread.qq.com/web/login/renewal\&quot;  # 刷新token的URL\nFIX_SYNCKEY_URL = \&quot;https://weread.qq.com/web/book/chapterInfos\&quot;  # 修复synckey的URL\n\n\ndef encode_data(data):\n    \&quot;\&quot;\&quot;数据编码：将字典转换为URL编码的字符串，并按键名排序\&quot;\&quot;\&quot;\n    return '&amp;'.join(f\&quot;{k}={urllib.parse.quote(str(data[k]), safe='')}\&quot; for k in sorted(data.keys()))\n\n\ndef cal_hash(input_string):\n    \&quot;\&quot;\&quot;计算哈希值：使用特定算法计算字符串的哈希值，用于请求校验\&quot;\&quot;\&quot;\n    _7032f5 = 0x15051505  # 初始化第一个哈希值\n    _cc1055 = _7032f5     # 初始化第二个哈希值\n    length = len(input_string)  # 获取输入字符串长度\n    _19094e = length - 1  # 从字符串末尾开始\n\n    # 循环处理字符串中的每对字符\n    while _19094e &gt; 0:\n        # 对第一个哈希值进行位运算\n        _7032f5 = 0x7fffffff &amp; (_7032f5 ^ ord(input_string[_19094e]) &lt;&lt; (length - _19094e) % 30)\n        # 对第二个哈希值进行位运算\n        _cc1055 = 0x7fffffff &amp; (_cc1055 ^ ord(input_string[_19094e - 1]) &lt;&lt; _19094e % 30)\n        _19094e -= 2  # 每次处理两个字符\n\n    # 返回两个哈希值相加后的十六进制表示（去掉0x前缀）\n    return hex(_7032f5 + _cc1055)[2:].lower()\n\ndef get_wr_skey():\n    \&quot;\&quot;\&quot;刷新cookie密钥：获取新的wr_skey值\&quot;\&quot;\&quot;\n    # 发送请求获取新的cookie\n    response = requests.post(RENEW_URL, headers=headers, cookies=cookies,\n                             data=json.dumps(COOKIE_DATA, separators=(',', ':')))\n    # 从响应头中提取wr_skey\n    for cookie in response.headers.get('Set-Cookie', '').split(';'):\n        if \&quot;wr_skey\&quot; in cookie:\n            return cookie.split('=')[-1][:8]  # 返回前8位\n    return None  # 如果没找到则返回None\n\ndef fix_no_synckey():\n    \&quot;\&quot;\&quot;修复synckey缺失问题：通过请求章节信息接口\&quot;\&quot;\&quot;\n    # 发送请求获取章节信息，间接修复synckey\n    requests.post(FIX_SYNCKEY_URL, headers=headers, cookies=cookies,\n                             data=json.dumps({\&quot;bookIds\&quot;:[\&quot;3300060341\&quot;]}, separators=(',', ':')))\n\ndef refresh_cookie():\n    \&quot;\&quot;\&quot;刷新cookie：获取并更新wr_skey\&quot;\&quot;\&quot;\n    logging.info(f\&quot; 刷新cookie\&quot;)\n    new_skey = get_wr_skey()  # 获取新的skey\n    if new_skey:\n        # 更新cookies中的wr_skey\n        cookies['wr_skey'] = new_skey\n        logging.info(f\&quot;✅ 密钥刷新成功，新密钥：{new_skey}\&quot;)\n        logging.info(f\&quot; 重新本次阅读。\&quot;)\n    else:\n        # 获取失败，记录错误并推送通知\n        ERROR_CODE = \&quot;❌ 无法获取新密钥或者WXREAD_CURL_BASH配置有误，终止运行。\&quot;\n        logging.error(ERROR_CODE)\n        push(ERROR_CODE, PUSH_METHOD)  # 推送错误信息\n        raise Exception(ERROR_CODE)  # 抛出异常终止程序\n\n# 主程序开始执行\n\n# 首先刷新cookie确保有效\nrefresh_cookie()\n\n# 初始化计数器和时间\nindex = 1  # 阅读次数计数器\nlastTime = int(time.time()) - 30  # 上次阅读时间（初始为当前时间减30秒）\n\n# 循环执行阅读操作，直到达到设定的次数\nwhile index &lt;= READ_NUM:\n    # 移除旧的校验和\n    data.pop('s')\n    \n    # 随机选择书籍和章节\n    data['b'] = random.choice(book)  # 随机选择一本书\n    data['c'] = random.choice(chapter)  # 随机选择一个章节\n    \n    # 更新时间相关字段\n    thisTime = int(time.time())  # 当前时间戳（秒）\n    data['ct'] = thisTime  # 当前时间\n    data['rt'] = thisTime - lastTime  # 阅读时长\n    data['ts'] = int(thisTime * 1000) + random.randint(0, 1000)  # 毫秒级时间戳加随机数\n    data['rn'] = random.randint(0, 1000)  # 随机数\n    \n    # 生成安全签名\n    data['sg'] = hashlib.sha256(f\&quot;{data['ts']}{data['rn']}{KEY}\&quot;.encode()).hexdigest()\n    \n    # 计算校验和\n    data['s'] = cal_hash(encode_data(data))\n\n    # 记录日志\n    logging.info(f\&quot;⏱️ 尝试第 {index} 次阅读...\&quot;)\n    logging.info(f\&quot; data: {data}\&quot;)\n    \n    # 发送阅读请求\n    response = requests.post(READ_URL, headers=headers, cookies=cookies, data=json.dumps(data, separators=(',', ':')))\n    resData = response.json()  # 解析响应JSON\n    logging.info(f\&quot; response: {resData}\&quot;)\n\n    # 处理响应结果\n    if 'succ' in resData:  # 请求成功\n        if 'synckey' in resData:  # 有同步键，表示阅读成功\n            lastTime = thisTime  # 更新上次阅读时间\n            index += 1  # 计数器加1\n            time.sleep(30)  # 等待30秒\n            logging.info(f\&quot;✅ 阅读成功，阅读进度：{(index - 1) * 0.5} 分钟\&quot;)\n        else:\n            # 没有synckey，尝试修复\n            logging.warning(\&quot;❌ 无synckey, 尝试修复...\&quot;)\n            fix_no_synckey()\n    else:\n        # 请求失败，可能是cookie过期\n        logging.warning(\&quot;❌ cookie 已过期，尝试刷新...\&quot;)\n        refresh_cookie()  # 刷新cookie\n\n# 所有阅读完成\nlogging.info(\&quot; 阅读脚本已完成！\&quot;)\n\n# 如果配置了推送方法，则发送完成通知\nif PUSH_METHOD not in (None, ''):\n    logging.info(\&quot;⏱️ 开始推送...\&quot;)\n    push(f\&quot; 微信读书自动阅读完成！\\n⏱️ 阅读时长：{(index - 1) * 0.5}分钟。\&quot;, PUSH_METHOD)\n````\n&quot;,&quot;workspace_file_chunks&quot;:[{&quot;char_start&quot;:&quot;0&quot;,&quot;char_end&quot;:&quot;646&quot;,&quot;blob_name&quot;:&quot;09cedc7333b97b881b3282a921e8a1083191be7480724aa7774357c6624e2dc0&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;main.py&quot;}},{&quot;char_start&quot;:&quot;646&quot;,&quot;char_end&quot;:&quot;1215&quot;,&quot;blob_name&quot;:&quot;09cedc7333b97b881b3282a921e8a1083191be7480724aa7774357c6624e2dc0&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;main.py&quot;}},{&quot;char_start&quot;:&quot;1215&quot;,&quot;char_end&quot;:&quot;1763&quot;,&quot;blob_name&quot;:&quot;09cedc7333b97b881b3282a921e8a1083191be7480724aa7774357c6624e2dc0&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;main.py&quot;}},{&quot;char_start&quot;:&quot;1763&quot;,&quot;char_end&quot;:&quot;2165&quot;,&quot;blob_name&quot;:&quot;09cedc7333b97b881b3282a921e8a1083191be7480724aa7774357c6624e2dc0&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;main.py&quot;}},{&quot;char_start&quot;:&quot;2165&quot;,&quot;char_end&quot;:&quot;2947&quot;,&quot;blob_name&quot;:&quot;09cedc7333b97b881b3282a921e8a1083191be7480724aa7774357c6624e2dc0&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;main.py&quot;}},{&quot;char_start&quot;:&quot;2947&quot;,&quot;char_end&quot;:&quot;3496&quot;,&quot;blob_name&quot;:&quot;09cedc7333b97b881b3282a921e8a1083191be7480724aa7774357c6624e2dc0&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;main.py&quot;}},{&quot;char_start&quot;:&quot;0&quot;,&quot;char_end&quot;:&quot;776&quot;,&quot;blob_name&quot;:&quot;5b5e1a7c619328925ee56f999c0469ec7fd94507b9c11e5e5eb8b72565b88f47&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;Dockerfile&quot;}},{&quot;char_start&quot;:&quot;0&quot;,&quot;char_end&quot;:&quot;758&quot;,&quot;blob_name&quot;:&quot;bbfc4f9d3687f11f24e0751daaf16f2b524ae5d0b3cc6eec01a88346a6d96ca3&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;README.md&quot;}},{&quot;char_start&quot;:&quot;758&quot;,&quot;char_end&quot;:&quot;1212&quot;,&quot;blob_name&quot;:&quot;bbfc4f9d3687f11f24e0751daaf16f2b524ae5d0b3cc6eec01a88346a6d96ca3&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;README.md&quot;}},{&quot;char_start&quot;:&quot;1212&quot;,&quot;char_end&quot;:&quot;1885&quot;,&quot;blob_name&quot;:&quot;bbfc4f9d3687f11f24e0751daaf16f2b524ae5d0b3cc6eec01a88346a6d96ca3&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;README.md&quot;}},{&quot;char_start&quot;:&quot;1885&quot;,&quot;char_end&quot;:&quot;2639&quot;,&quot;blob_name&quot;:&quot;bbfc4f9d3687f11f24e0751daaf16f2b524ae5d0b3cc6eec01a88346a6d96ca3&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;README.md&quot;}},{&quot;char_start&quot;:&quot;2639&quot;,&quot;char_end&quot;:&quot;3365&quot;,&quot;blob_name&quot;:&quot;bbfc4f9d3687f11f24e0751daaf16f2b524ae5d0b3cc6eec01a88346a6d96ca3&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;README.md&quot;}},{&quot;char_start&quot;:&quot;3365&quot;,&quot;char_end&quot;:&quot;3557&quot;,&quot;blob_name&quot;:&quot;bbfc4f9d3687f11f24e0751daaf16f2b524ae5d0b3cc6eec01a88346a6d96ca3&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;README.md&quot;}},{&quot;char_start&quot;:&quot;3557&quot;,&quot;char_end&quot;:&quot;4309&quot;,&quot;blob_name&quot;:&quot;bbfc4f9d3687f11f24e0751daaf16f2b524ae5d0b3cc6eec01a88346a6d96ca3&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;README.md&quot;}},{&quot;char_start&quot;:&quot;4309&quot;,&quot;char_end&quot;:&quot;4358&quot;,&quot;blob_name&quot;:&quot;bbfc4f9d3687f11f24e0751daaf16f2b524ae5d0b3cc6eec01a88346a6d96ca3&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;README.md&quot;}},{&quot;char_start&quot;:&quot;0&quot;,&quot;char_end&quot;:&quot;583&quot;,&quot;blob_name&quot;:&quot;0593b0df9fef649e16e3b424f3823d8c3add22e239099d4c5b6977050e88ecec&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;config.py&quot;}},{&quot;char_start&quot;:&quot;583&quot;,&quot;char_end&quot;:&quot;1047&quot;,&quot;blob_name&quot;:&quot;0593b0df9fef649e16e3b424f3823d8c3add22e239099d4c5b6977050e88ecec&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;config.py&quot;}},{&quot;char_start&quot;:&quot;1047&quot;,&quot;char_end&quot;:&quot;1524&quot;,&quot;blob_name&quot;:&quot;0593b0df9fef649e16e3b424f3823d8c3add22e239099d4c5b6977050e88ecec&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;config.py&quot;}},{&quot;char_start&quot;:&quot;1524&quot;,&quot;char_end&quot;:&quot;1869&quot;,&quot;blob_name&quot;:&quot;0593b0df9fef649e16e3b424f3823d8c3add22e239099d4c5b6977050e88ecec&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;config.py&quot;}},{&quot;char_start&quot;:&quot;1869&quot;,&quot;char_end&quot;:&quot;2324&quot;,&quot;blob_name&quot;:&quot;0593b0df9fef649e16e3b424f3823d8c3add22e239099d4c5b6977050e88ecec&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;config.py&quot;}},{&quot;char_start&quot;:&quot;2324&quot;,&quot;char_end&quot;:&quot;2810&quot;,&quot;blob_name&quot;:&quot;0593b0df9fef649e16e3b424f3823d8c3add22e239099d4c5b6977050e88ecec&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;config.py&quot;}},{&quot;char_start&quot;:&quot;2810&quot;,&quot;char_end&quot;:&quot;3644&quot;,&quot;blob_name&quot;:&quot;0593b0df9fef649e16e3b424f3823d8c3add22e239099d4c5b6977050e88ecec&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;config.py&quot;}},{&quot;char_start&quot;:&quot;3644&quot;,&quot;char_end&quot;:&quot;3881&quot;,&quot;blob_name&quot;:&quot;0593b0df9fef649e16e3b424f3823d8c3add22e239099d4c5b6977050e88ecec&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;config.py&quot;}},{&quot;char_start&quot;:&quot;0&quot;,&quot;char_end&quot;:&quot;65&quot;,&quot;blob_name&quot;:&quot;c8a8c090a3061845fc4f889b1768d0fbdd0ff69303dde47aaa84e0888138f720&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;.gitignore&quot;}},{&quot;char_start&quot;:&quot;0&quot;,&quot;char_end&quot;:&quot;310&quot;,&quot;blob_name&quot;:&quot;f0bafbff69b3c07185a59268124b61c8534bc42d5e1728fed1e37b1a790fffa7&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;.github/workflows/deploy.yml&quot;}},{&quot;char_start&quot;:&quot;310&quot;,&quot;char_end&quot;:&quot;946&quot;,&quot;blob_name&quot;:&quot;f0bafbff69b3c07185a59268124b61c8534bc42d5e1728fed1e37b1a790fffa7&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;.github/workflows/deploy.yml&quot;}},{&quot;char_start&quot;:&quot;946&quot;,&quot;char_end&quot;:&quot;1425&quot;,&quot;blob_name&quot;:&quot;f0bafbff69b3c07185a59268124b61c8534bc42d5e1728fed1e37b1a790fffa7&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;.github/workflows/deploy.yml&quot;}},{&quot;char_start&quot;:&quot;0&quot;,&quot;char_end&quot;:&quot;734&quot;,&quot;blob_name&quot;:&quot;e49c4f24d89e8978e83c016039a35986e4d5bbba9161839857b9d8b03efa13cb&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;push.py&quot;}},{&quot;char_start&quot;:&quot;734&quot;,&quot;char_end&quot;:&quot;1752&quot;,&quot;blob_name&quot;:&quot;e49c4f24d89e8978e83c016039a35986e4d5bbba9161839857b9d8b03efa13cb&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;push.py&quot;}},{&quot;char_start&quot;:&quot;1752&quot;,&quot;char_end&quot;:&quot;2589&quot;,&quot;blob_name&quot;:&quot;e49c4f24d89e8978e83c016039a35986e4d5bbba9161839857b9d8b03efa13cb&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;push.py&quot;}},{&quot;char_start&quot;:&quot;2589&quot;,&quot;char_end&quot;:&quot;3324&quot;,&quot;blob_name&quot;:&quot;e49c4f24d89e8978e83c016039a35986e4d5bbba9161839857b9d8b03efa13cb&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;push.py&quot;}},{&quot;char_start&quot;:&quot;3324&quot;,&quot;char_end&quot;:&quot;3915&quot;,&quot;blob_name&quot;:&quot;e49c4f24d89e8978e83c016039a35986e4d5bbba9161839857b9d8b03efa13cb&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;push.py&quot;}},{&quot;char_start&quot;:&quot;0&quot;,&quot;char_end&quot;:&quot;39&quot;,&quot;blob_name&quot;:&quot;5a5f4f85a0937b04443eb957206cd3248336b34b9c4a119c44e0a5adca444329&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;.vscode/settings.json&quot;}}]},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;a4fc4613-5fff-4e75-bb7f-57f7f5b2f8a8&quot;,&quot;request_message&quot;:&quot;添加整个仓库代码的每个 .py、.yml、Dockerfile 文件添加全量注释, 详细说明代码的的作用&quot;,&quot;rich_text_json_repr&quot;:{&quot;type&quot;:&quot;doc&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;paragraph&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;添加整个仓库代码的每个 .py、.yml、Dockerfile 文件添加全量注释, 详细说明代码的的作用&quot;}]}]},&quot;mentioned_items&quot;:[],&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:0,&quot;content&quot;:&quot;我将为仓库中的每个主要文件添加详细注释。让我们从每个文件开始：\n\n&lt;augment_code_snippet path=\&quot;main.py\&quot; mode=\&quot;EDIT\&quot;&gt;\n```python\n# main.py - 主逻辑文件\n# 功能：实现微信读书自动阅读功能，包括请求构建、加密签名生成、自动刷新cookie等核心功能\n# 作者：findmover\n# 版本：5.0\n\nimport re\nimport json\nimport time\nimport random\nimport logging\nimport hashlib\nimport requests\nimport urllib.parse\nfrom push import push  # 导入推送模块，用于发送通知\nfrom config import data, headers, cookies, READ_NUM, PUSH_METHOD, book, chapter  # 导入配置信息\n\n# 配置日志格式，便于调试和查看运行状态\nlogger = logging.getLogger(__name__)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)-8s - %(message)s')\n\n# 关键常量定义\nKEY = \&quot;3c5c8717f3daf09iop3423zafeqoi\&quot;  # 用于生成安全签名的密钥，通过逆向JS获得\nCOOKIE_DATA = {\&quot;rq\&quot;: \&quot;%2Fweb%2Fbook%2Fread\&quot;}  # 刷新cookie时的请求数据\nREAD_URL = \&quot;https://weread.qq.com/web/book/read\&quot;  # 微信读书阅读接口URL\nRENEW_URL = \&quot;https://weread.qq.com/web/login/renewal\&quot;  # 刷新token的URL\nFIX_SYNCKEY_URL = \&quot;https://weread.qq.com/web/book/chapterInfos\&quot;  # 修复synckey的URL\n\n\ndef encode_data(data):\n    \&quot;\&quot;\&quot;\n    数据编码函数：将字典转换为URL编码的字符串，并按键名排序\n    参数:\n        data: 包含请求参数的字典\n    返回:\n        按键名排序并URL编码后的字符串\n    \&quot;\&quot;\&quot;\n    return '&amp;'.join(f\&quot;{k}={urllib.parse.quote(str(data[k]), safe='')}\&quot; for k in sorted(data.keys()))\n\n\ndef cal_hash(input_string):\n    \&quot;\&quot;\&quot;\n    计算哈希值：使用特定算法计算字符串的哈希值，用于请求校验\n    这是从微信读书前端JS逆向得到的算法\n    参数:\n        input_string: 需要计算哈希的字符串\n    返回:\n        计算后的哈希值（十六进制字符串）\n    \&quot;\&quot;\&quot;\n    _7032f5 = 0x15051505  # 初始化第一个哈希值\n    _cc1055 = _7032f5     # 初始化第二个哈希值\n    length = len(input_string)  # 获取输入字符串长度\n    _19094e = length - 1  # 从字符串末尾开始\n\n    # 循环处理字符串中的每对字符\n    while _19094e &gt; 0:\n        # 对第一个哈希值进行位运算\n        _7032f5 = 0x7fffffff &amp; (_7032f5 ^ ord(input_string[_19094e]) &lt;&lt; (length - _19094e) % 30)\n        # 对第二个哈希值进行位运算\n        _cc1055 = 0x7fffffff &amp; (_cc1055 ^ ord(input_string[_19094e - 1]) &lt;&lt; _19094e % 30)\n        _19094e -= 2  # 每次处理两个字符\n\n    # 返回两个哈希值相加后的十六进制表示（去掉0x前缀）\n    return hex(_7032f5 + _cc1055)[2:].lower()\n\ndef get_wr_skey():\n    \&quot;\&quot;\&quot;\n    刷新cookie密钥：获取新的wr_skey值\n    微信读书的cookie需要定期刷新，此函数负责获取新的密钥\n    返回:\n        成功返回新的wr_skey值，失败返回None\n    \&quot;\&quot;\&quot;\n    # 发送请求获取新的cookie\n    response = requests.post(RENEW_URL, headers=headers, cookies=cookies,\n                             data=json.dumps(COOKIE_DATA, separators=(',', ':')))\n    # 从响应头中提取wr_skey\n    for cookie in response.headers.get('Set-Cookie', '').split(';'):\n        if \&quot;wr_skey\&quot; in cookie:\n            return cookie.split('=')[-1][:8]  # 返回前8位\n    return None  # 如果没找到则返回None\n\ndef fix_no_synckey():\n    \&quot;\&quot;\&quot;\n    修复synckey缺失问题：通过请求章节信息接口\n    有时阅读请求会返回没有synckey的情况，需要通过此函数修复\n    \&quot;\&quot;\&quot;\n    # 发送请求获取章节信息，间接修复synckey\n    requests.post(FIX_SYNCKEY_URL, headers=headers, cookies=cookies,\n                             data=json.dumps({\&quot;bookIds\&quot;:[\&quot;3300060341\&quot;]}, separators=(',', ':')))\n\ndef refresh_cookie():\n    \&quot;\&quot;\&quot;\n    刷新cookie：获取并更新wr_skey\n    这是保持会话有效的关键函数\n    \&quot;\&quot;\&quot;\n    logging.info(f\&quot; 刷新cookie\&quot;)\n    new_skey = get_wr_skey()  # 获取新的skey\n    if new_skey:\n        # 更新cookies中的wr_skey\n        cookies['wr_skey'] = new_skey\n        logging.info(f\&quot;✅ 密钥刷新成功，新密钥：{new_skey}\&quot;)\n        logging.info(f\&quot; 重新本次阅读。\&quot;)\n    else:\n        # 获取失败，记录错误并推送通知\n        ERROR_CODE = \&quot;❌ 无法获取新密钥或者WXREAD_CURL_BASH配置有误，终止运行。\&quot;\n        logging.error(ERROR_CODE)\n        push(ERROR_CODE, PUSH_METHOD)  # 推送错误信息\n        raise Exception(ERROR_CODE)  # 抛出异常终止程序\n\n# 主程序开始执行\n\n# 首先刷新cookie确保有效\nrefresh_cookie()\n\n# 初始化计数器和时间\nindex = 1  # 阅读次数计数器\nlastTime = int(time.time()) - 30  # 上次阅读时间（初始为当前时间减30秒）\n\n# 循环执行阅读操作，直到达到设定的次数\nwhile index &lt;= READ_NUM:\n    # 移除旧的校验和\n    data.pop('s')\n    \n    # 随机选择书籍和章节，增加真实性\n    data['b'] = random.choice(book)  # 随机选择一本书\n    data['c'] = random.choice(chapter)  # 随机选择一个章节\n    \n    # 更新时间相关字段\n    thisTime = int(time.time())  # 当前时间戳（秒）\n    data['ct'] = thisTime  # 当前时间\n    data['rt'] = thisTime - lastTime  # 阅读时长\n    data['ts'] = int(thisTime * 1000) + random.randint(0, 1000)  # 毫秒级时间戳加随机数\n    data['rn'] = random.randint(0, 1000)  # 随机数\n    \n    # 生成安全签名\n    data['sg'] = hashlib.sha256(f\&quot;{data['ts']}{data['rn']}{KEY}\&quot;.encode()).hexdigest()\n    \n    # 计算校验和\n    data['s'] = cal_hash(encode_data(data))\n\n    # 记录日志\n    logging.info(f\&quot;⏱️ 尝试第 {index} 次阅读...\&quot;)\n    logging.info(f\&quot; data: {data}\&quot;)\n    \n    # 发送阅读请求\n    response = requests.post(READ_URL, headers=headers, cookies=cookies, data=json.dumps(data, separators=(',', ':')))\n    resData = response.json()  # 解析响应JSON\n    logging.info(f\&quot; response: {resData}\&quot;)\n\n    # 处理响应结果\n    if 'succ' in resData:  # 请求成功\n        if 'synckey' in resData:  # 有同步键，表示阅读成功\n            lastTime = thisTime  # 更新上次阅读时间\n            index += 1  # 计数器加1\n            time.sleep(30)  # 等待30秒，模拟真实阅读间隔\n            logging.info(f\&quot;✅ 阅读成功，阅读进度：{(index - 1) * 0.5} 分钟\&quot;)\n        else:\n            # 没有synckey，尝试修复\n            logging.warning(\&quot;❌ 无synckey, 尝试修复...\&quot;)\n            fix_no_synckey()\n    else:\n        # 请求失败，可能是cookie过期\n        logging.warning(\&quot;❌ cookie 已过期，尝试刷新...\&quot;)\n        refresh_cookie()  # 刷新cookie\n\n# 所有阅读完成\nlogging.info(\&quot; 阅读脚本已完成！\&quot;)\n\n# 如果配置了推送方法，则发送完成通知\nif PUSH_METHOD not in (None, ''):\n    logging.info(\&quot;⏱️ 开始推送...\&quot;)\n    push(f\&quot; 微信读书自动阅读完成！\\n⏱️ 阅读时长：{(index - 1) * 0.5}分钟。\&quot;, PUSH_METHOD)\n```\n&lt;/augment_code_snippet&gt;\n\n&lt;augment_code_snippet path=\&quot;config.py\&quot; mode=\&quot;EDIT\&quot;&gt;\n```python\n# config.py - 配置文件\n# 功能：存储脚本运行所需的各种配置参数，包括阅读次数、推送设置、请求头和cookies等\n# 作者：findmover\n# 版本：5.0\n\nimport os\nimport re\n\n\&quot;\&quot;\&quot;\n可修改区域\n默认使用本地值如果不存在从环境变量中获取值\n这样设计便于在不同环境（本地、Docker、GitHub Actions）中灵活配置\n\&quot;\&quot;\&quot;\n\n# 阅读次数 默认40次/20分钟，每次阅读约30秒\nREAD_NUM = int(os.getenv('READ_NUM') or 40)\n\n# 推送相关配置\n# 需要推送时可选，可选pushplus、wxpusher、telegram\nPUSH_METHOD = \&quot;\&quot; or os.getenv('PUSH_METHOD')\n\n# pushplus推送时需填写的token\nPUSHPLUS_TOKEN = \&quot;\&quot; or os.getenv(\&quot;PUSHPLUS_TOKEN\&quot;)\n\n# telegram推送时需填写的bot token和chat id\nTELEGRAM_BOT_TOKEN = \&quot;\&quot; or os.getenv(\&quot;TELEGRAM_BOT_TOKEN\&quot;)\nTELEGRAM_CHAT_ID = \&quot;\&quot; or os.getenv(\&quot;TELEGRAM_CHAT_ID\&quot;)\n\n# wxpusher推送时需填写的token\nWXPUSHER_SPT = \&quot;\&quot; or os.getenv(\&quot;WXPUSHER_SPT\&quot;)\n\n# read接口的bash命令，本地部署时可对应替换headers、cookies\n# 从环境变量获取curl命令，用于提取headers和cookies\ncurl_str = os.getenv('WXREAD_CURL_BASH')\n\n# headers、cookies是一个省略模版，本地或者docker部署时对应替换\n# 这些是默认的cookies，如果提供了curl_str，将被覆盖\ncookies = {\n    'RK': 'oxEY1bTnXf',\n    'ptcz': '53e3b35a9486dd63c4d06430b05aa169402117fc407dc5cc9329b41e59f62e2b',\n    'pac_uid': '0_e63870bcecc18',\n    'iip': '0',\n    '_qimei_uuid42': '183070d3135100ee797b08bc922054dc3062834291',\n    'wr_avatar': 'https%3A%2F%2Fthirdwx.qlogo.cn%2Fmmopen%2Fvi_32%2FeEOpSbFh2Mb1bUxMW9Y3FRPfXwWvOLaNlsjWIkcKeeNg6vlVS5kOVuhNKGQ1M8zaggLqMPmpE5qIUdqEXlQgYg%2F132',\n    'wr_gender': '0',\n}\n\n# 默认请求头，如果提供了curl_str，将被覆盖\nheaders = {\n    'accept': 'application/json, text/plain, */*',\n    'accept-language': 'zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6,ko;q=0.5',\n    'baggage': 'sentry-environment=production,sentry-release=dev-1730698697208,sentry-public_key=ed67ed71f7804a038e898ba54bd66e44,sentry-trace_id=1ff5a0725f8841088b42f97109c45862',\n    'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36 Edg/131.0.0.0',\n}\n\n\n# 书籍ID列表，随机选择一本书进行阅读\n# 这些ID是通过抓包获取的，代表不同的书籍\nbook = [\n    \&quot;36d322f07186022636daa5e\&quot;,\&quot;6f932ec05dd9eb6f96f14b9\&quot;,\&quot;43f3229071984b9343f04a4\&quot;,\&quot;d7732ea0813ab7d58g0184b8\&quot;,\n    \&quot;3d03298058a9443d052d409\&quot;,\&quot;4fc328a0729350754fc56d4\&quot;,\&quot;a743220058a92aa746632c0\&quot;,\&quot;140329d0716ce81f140468e\&quot;,\n    \&quot;1d9321c0718ff5e11d9afe8\&quot;,\&quot;ff132750727dc0f6ff1f7b5\&quot;,\&quot;e8532a40719c4eb7e851cbe\&quot;,\&quot;9b13257072562b5c9b1c8d6\&quot;\n]\n\n# 章节ID列表，随机选择一个章节进行阅读\n# 这些ID是通过抓包获取的，代表不同的章节\nchapter = [\n    \&quot;ecc32f3013eccbc87e4b62e\&quot;,\&quot;a87322c014a87ff679a21ea\&quot;,\&quot;e4d32d5015e4da3b7fbb1fa\&quot;,\&quot;16732dc0161679091c5aeb1\&quot;,\n    \&quot;8f132430178f14e45fce0f7\&quot;,\&quot;c9f326d018c9f0f895fb5e4\&quot;,\&quot;45c322601945c48cce2e120\&quot;,\&quot;d3d322001ad3d9446802347\&quot;,\n    \&quot;65132ca01b6512bd43d90e3\&quot;,\&quot;c20321001cc20ad4d76f5ae\&quot;,\&quot;c51323901dc51ce410c121b\&quot;,\&quot;aab325601eaab3238922e53\&quot;,\n    \&quot;9bf32f301f9bf31c7ff0a60\&quot;,\&quot;c7432af0210c74d97b01b1c\&quot;,\&quot;70e32fb021170efdf2eca12\&quot;,\&quot;6f4322302126f4922f45dec\&quot;\n]\n\n\&quot;\&quot;\&quot;\n建议保留区域|默认读三体，其它书籍自行测试时间是否增加\n这部分包含了请求所需的基本参数，通过逆向分析获得\n\&quot;\&quot;\&quot;\ndata = {\n    \&quot;appId\&quot;: \&quot;wb182564874603h266381671\&quot;,  # 应用ID\n    \&quot;b\&quot;: \&quot;ce032b305a9bc1ce0b0dd2a\&quot;,       # 书籍ID，会被随机替换\n    \&quot;c\&quot;: \&quot;7f632b502707f6ffaa6bf2e\&quot;,       # 章节ID，会被随机替换\n    \&quot;ci\&quot;: 27,                             # 章节索引\n    \&quot;co\&quot;: 389,                            # 内容位置\n    \&quot;sm\&quot;: \&quot;19聚会《三体》网友的聚会地点是一处僻静\&quot;,  # 内容摘要\n    \&quot;pr\&quot;: 74,                             # 页码或进度\n    \&quot;rt\&quot;: 15,                             # 阅读时长\n    \&quot;ts\&quot;: 1744264311434,                  # 时间戳（毫秒）\n    \&quot;rn\&quot;: 466,                            # 随机数\n    \&quot;sg\&quot;: \&quot;2b2ec618394b99deea35104168b86381da9f8946d4bc234e062fa320155409fb\&quot;,  # 安全签名\n    \&quot;ct\&quot;: 1744264311,                     # 时间戳（秒）\n    \&quot;ps\&quot;: \&quot;4ee326507a65a465g015fae\&quot;,      # 用户标识\n    \&quot;pc\&quot;: \&quot;aab32e207a65a466g010615\&quot;,      # 设备标识\n    \&quot;s\&quot;: \&quot;36cc0815\&quot;                       # 校验和\n}\n\n\ndef convert(curl_command):\n    \&quot;\&quot;\&quot;\n    提取bash接口中的headers与cookies\n    支持 -H 'Cookie: xxx' 和 -b 'xxx' 两种方式的cookie提取\n    \n    参数:\n        curl_command: curl命令字符串\n    返回:\n        headers: 提取的请求头字典\n        cookies: 提取的cookies字典\n    \&quot;\&quot;\&quot;\n    # 提取 headers\n    headers_temp = {}\n    for match in re.findall(r\&quot;-H '([^:]+): ([^']+)'\&quot;, curl_command):\n        headers_temp[match[0]] = match[1]\n\n    # 提取 cookies\n    cookies = {}\n    \n    # 从 -H 'Cookie: xxx' 提取\n    cookie_header = next((v for k, v in headers_temp.items() \n                         if k.lower() == 'cookie'), '')\n    \n    # 从 -b 'xxx' 提取\n    cookie_b = re.search(r\&quot;-b '([^']+)'\&quot;, curl_command)\n    cookie_string = cookie_b.group(1) if cookie_b else cookie_header\n    \n    # 解析 cookie 字符串\n    if cookie_string:\n        for cookie in cookie_string.split('; '):\n            if '=' in cookie:\n                key, value = cookie.split('=', 1)\n                cookies[key.strip()] = value.strip()\n    \n    # 移除 headers 中的 Cookie/cookie\n    headers = {k: v for k, v in headers_temp.items() \n              if k.lower() != 'cookie'}\n\n    return headers, cookies\n\n\n# 如果提供了curl命令，则从中提取headers和cookies，否则使用默认值\nheaders, cookies = convert(curl_str) if curl_str else (headers, cookies)\n```\n&lt;/augment_code_snippet&gt;\n\n&lt;augment_code_snippet path=\&quot;push.py\&quot; mode=\&quot;EDIT\&quot;&gt;\n```python\n# push.py - 消息推送模块\n# 功能：支持多种推送方式（PushPlus、wxpusher、Telegram）发送通知消息\n# 作者：findmover\n# 版本：5.0\n\nimport os\nimport random\nimport time\nimport json\nimport requests\nimport logging\nfrom config import PUSHPLUS_TOKEN, TELEGRAM_CHAT_ID, TELEGRAM_BOT_TOKEN, WXPUSHER_SPT\n\n# 获取logger实例\nlogger = logging.getLogger(__name__)\n\n\nclass PushNotification:\n    \&quot;\&quot;\&quot;\n    推送通知类：封装了多种推送方式的实现\n    支持PushPlus、Telegram和WxPusher三种推送渠道\n    \&quot;\&quot;\&quot;\n    \n    def __init__(self):\n        \&quot;\&quot;\&quot;初始化推送通知类，设置各推送渠道的URL和请求头\&quot;\&quot;\&quot;\n        self.pushplus_url = \&quot;https://www.pushplus.plus/send\&quot;  # PushPlus推送API\n        self.telegram_url = \&quot;https://api.telegram.org/bot{}/sendMessage\&quot;  # Telegram API\n        self.headers = {'Content-Type': 'application/json'}  # 通用请求头\n        \n        # 从环境变量获取代理设置，用于Telegram推送\n        self.proxies = {\n            'http': os.getenv('http_proxy'),\n            'https': os.getenv('https_proxy')\n        }\n        \n        # WxPusher简易推送URL\n        self.wxpusher_simple_url = \&quot;https://wxpusher.zjiecode.com/api/send/message/{}/{}\&quot;\n\n    def push_pushplus(self, content, token):\n        \&quot;\&quot;\&quot;\n        PushPlus消息推送\n        \n        参数:\n            content: 推送内容\n            token: PushPlus的token\n        \&quot;\&quot;\&quot;\n        attempts = 5  # 最大尝试次数\n        for attempt in range(attempts):\n            try:\n                # 发送POST请求到PushPlus\n                response = requests.post(\n                    self.pushplus_url,\n                    data=json.dumps({\n                        \&quot;token\&quot;: token,\n                        \&quot;title\&quot;: \&quot;微信阅读推送...\&quot;,\n                        \&quot;content\&quot;: content\n                    }).encode('utf-8'),\n                    headers=self.headers,\n                    timeout=10\n                )\n                response.raise_for_status()  # 检查响应状态\n                logger.info(\&quot;✅ PushPlus响应: %s\&quot;, response.text)\n                break  # 成功推送，跳出循环\n            except requests.exceptions.RequestException as e:\n                logger.error(\&quot;❌ PushPlus推送失败: %s\&quot;, e)\n                if attempt &lt; attempts - 1:  # 如果不是最后一次尝试\n                    sleep_time = random.randint(180, 360)  # 随机3到6分钟\n                    logger.info(\&quot;将在 %d 秒后重试...\&quot;, sleep_time)\n                    time.sleep(sleep_time)  # 等待一段时间后重试\n\n    def push_telegram(self, content, bot_token, chat_id):\n        \&quot;\&quot;\&quot;\n        Telegram消息推送，失败时自动尝试直连\n        \n        参数:\n            content: 推送内容\n            bot_token: Telegram机器人token\n            chat_id: 聊天ID\n            \n        返回:\n            bool: 推送成功返回True，否则返回False\n        \&quot;\&quot;\&quot;\n        url = self.telegram_url.format(bot_token)  # 格式化URL\n        payload = {\&quot;chat_id\&quot;: chat_id, \&quot;text\&quot;: content}  # 请求数据\n\n        try:\n            # 先尝试使用代理\n            response = requests.post(url, json=payload, proxies=self.proxies, timeout=30)\n            logger.info(\&quot;✅ Telegram响应: %s\&quot;, response.text)\n            response.raise_for_status()\n            return True\n        except Exception as e:\n            logger.error(\&quot;❌ Telegram代理发送失败: %s\&quot;, e)\n            try:\n                # 代理失败后直连\n                response = requests.post(url, json=payload, timeout=30)\n                response.raise_for_status()\n                return True\n            except Exception as e:\n                logger.error(\&quot;❌ Telegram发送失败: %s\&quot;, e)\n                return False\n    \n    def push_wxpusher(self, content, spt):\n        \&quot;\&quot;\&quot;\n        WxPusher消息推送（极简方式）\n        \n        参数:\n            content: 推送内容\n            spt: WxPusher的SPT参数\n        \&quot;\&quot;\&quot;\n        attempts = 5  # 最大尝试次数\n        url = self.wxpusher_simple_url.format(spt, content)  # 格式化URL\n        \n        for attempt in range(attempts):\n            try:\n                # 发送GET请求到WxPusher\n                response = requests.get(url, timeout=10)\n                response.raise_for_status()  # 检查响应状态\n                logger.info(\&quot;✅ WxPusher响应: %s\&quot;, response.text)\n                break  # 成功推送，跳出循环\n            except requests.exceptions.RequestException as e:\n                logger.error(\&quot;❌ WxPusher推送失败: %s\&quot;, e)\n                if attempt &lt; attempts - 1:  # 如果不是最后一次尝试\n                    sleep_time = random.randint(180, 360)  # 随机3到6分钟\n                    logger.info(\&quot;将在 %d 秒后重试...\&quot;, sleep_time)\n                    time.sleep(sleep_time)  # 等待一段时间后重试\n\n\n\&quot;\&quot;\&quot;外部调用接口\&quot;\&quot;\&quot;\n\n\ndef push(content, method):\n    \&quot;\&quot;\&quot;\n    统一推送接口，支持多种推送方式\n    \n    参数:\n        content: 推送内容\n        method: 推送方式，支持'pushplus'、'telegram'和'wxpusher'\n        \n    返回:\n        根据不同推送方式返回相应结果\n        \n    异常:\n        ValueError: 当提供的推送方式无效时抛出\n    \&quot;\&quot;\&quot;\n    notifier = PushNotification()  # 创建推送通知实例\n\n    if method == \&quot;pushplus\&quot;:\n        token = PUSHPLUS_TOKEN\n        return notifier.push_pushplus(content, token)\n    elif method == \&quot;telegram\&quot;:\n        bot_token = TELEGRAM_BOT_TOKEN\n        chat_id = TELEGRAM_CHAT_ID\n        return notifier.push_telegram(content, bot_token, chat_id)\n    elif method == \&quot;wxpusher\&quot;:\n        return notifier.push_wxpusher(content, WXPUSHER_SPT)\n    else:\n        raise ValueError(\&quot;❌ 无效的通知渠道，请选择 'pushplus'、'telegram' 或 'wxpusher'\&quot;)\n```\n&lt;/augment_code_snippet&gt;\n\n&lt;augment_code_snippet path=\&quot;.github/workflows/deploy.yml\&quot; mode=\&quot;EDIT\&quot;&gt;\n```yaml\n# deploy.yml - GitHub Actions工作流配置文件\n# 功能：定义自动化工作流，定时或手动触发微信读书自动阅读脚本\n# 作者：findmover\n# 版本：5.0\n\nname: wxread  # 工作流名称\n\non:\n  schedule:\n    # 定时触发配置\n    # 凌晨任务：北京时间每天 01:00（UTC 前一天 17:00）\n    - cron: '0 17 * * *'\n    # 早间任务：北京时间每天 05:00（UTC 前一天 21:00）\n    #- cron: '0 21 * * *'\n    # 午间任务：北京时间每天 11:40（UTC 03:40）\n    #- cron: '40 3 * * *'\n    # 晚间任务：北京时间每天 22:00（UTC 14:00）\n    #- cron: '0 14 * * *'\n  workflow_dispatch:  # 允许手动触发工作流\n\njobs:\n  deploy:\n    runs-on: ubuntu-22.04  # 指定运行环境\n    environment: AutoRead  # 指定GitHub环境，用于存储敏感信息\n\n    steps:\n    # 设置DNS为Google的DNS服务器，避免DNS解析问题\n    - name: Set DNS to Google's DNS\n      run: |\n        echo \&quot;nameserver 8.8.8.8\&quot; | sudo tee /etc/resolv.conf\n        echo \&quot;nameserver 8.8.4.4\&quot; | sudo tee -a /etc/resolv.conf\n\n    # 检出代码仓库\n    - name: Checkout repository\n      uses: actions/checkout@v2\n\n    # 设置Python环境\n    - name: Set up Python\n      uses: actions/setup-python@v2\n      with:\n        python-version: '3.10'  # 指定Python版本\n\n    # 安装依赖包\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install certifi==2024.8.30 charset-normalizer==3.4.0 idna==3.10 requests==2.32.3 urllib3==2.2.3\n\n    # 运行脚本\n    - name: Run deployment script\n      env:\n        # 设置环境变量，从GitHub Secrets和Variables获取\n        WXREAD_CURL_BASH: ${{ secrets.WXREAD_CURL_BASH }}  # 微信读书curl命令\n        PUSH_METHOD: ${{ secrets.PUSH_METHOD }}  # 推送方式\n        PUSHPLUS_TOKEN: ${{ secrets.PUSHPLUS_TOKEN }}  # PushPlus token\n        WXPUSHER_SPT: ${{ secrets.WXPUSHER_SPT }}  # WxPusher token\n        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}  # Telegram bot token\n        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}  # Telegram chat ID\n        READ_NUM: ${{ vars.READ_NUM }}  # 阅读次数，使用Repository Variables\n\n      run: |\n        python main.py  # 执行主脚本\n```\n&lt;/augment_code_snippet&gt;\n\n&lt;augment_code_snippet path=\&quot;Dockerfile\&quot; mode=\&quot;EDIT\&quot;&gt;\n```dockerfile\n# Dockerfile - Docker容器配置文件\n# 功能：定义Docker镜像构建过程，用于在容器中运行微信读书自动阅读脚本\n# 作者：findmover\n# 版本：5.0\n\n# 使用Python 3.10精简版作为基础镜像\nFROM python:3.10-slim\n\n# 设置工作目录\nWORKDIR /app\n\n# 设置时区为中国时区，确保日志时间正确\nENV TZ=Asia/Shanghai\nRUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone\n\n# 安装 cron 定时任务工具\n# 更新apt源并安装cron，安装完成后清理apt缓存减小镜像体积\nRUN apt-get update &amp;&amp; apt-get install -y cron &amp;&amp; rm -rf /var/lib/apt/lists/*\nENV PATH=\&quot;/usr/local/bin:${PATH}\&quot;  # 确保Python\n```\n&lt;/augment_code_snippet&gt;&quot;},{&quot;id&quot;:2,&quot;type&quot;:2,&quot;content&quot;:&quot;我将为仓库中的每个主要文件添加详细注释。让我们从每个文件开始：\n\n````python path=main.py mode=EDIT\n# main.py - 主逻辑文件\n# 功能：实现微信读书自动阅读功能，包括请求构建、加密签名生成、自动刷新cookie等核心功能\n# 作者：findmover\n# 版本：5.0\n\nimport re\nimport json\nimport time\nimport random\nimport logging\nimport hashlib\nimport requests\nimport urllib.parse\nfrom push import push  # 导入推送模块，用于发送通知\nfrom config import data, headers, cookies, READ_NUM, PUSH_METHOD, book, chapter  # 导入配置信息\n\n# 配置日志格式，便于调试和查看运行状态\nlogger = logging.getLogger(__name__)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)-8s - %(message)s')\n\n# 关键常量定义\nKEY = \&quot;3c5c8717f3daf09iop3423zafeqoi\&quot;  # 用于生成安全签名的密钥，通过逆向JS获得\nCOOKIE_DATA = {\&quot;rq\&quot;: \&quot;%2Fweb%2Fbook%2Fread\&quot;}  # 刷新cookie时的请求数据\nREAD_URL = \&quot;https://weread.qq.com/web/book/read\&quot;  # 微信读书阅读接口URL\nRENEW_URL = \&quot;https://weread.qq.com/web/login/renewal\&quot;  # 刷新token的URL\nFIX_SYNCKEY_URL = \&quot;https://weread.qq.com/web/book/chapterInfos\&quot;  # 修复synckey的URL\n\n\ndef encode_data(data):\n    \&quot;\&quot;\&quot;\n    数据编码函数：将字典转换为URL编码的字符串，并按键名排序\n    参数:\n        data: 包含请求参数的字典\n    返回:\n        按键名排序并URL编码后的字符串\n    \&quot;\&quot;\&quot;\n    return '&amp;'.join(f\&quot;{k}={urllib.parse.quote(str(data[k]), safe='')}\&quot; for k in sorted(data.keys()))\n\n\ndef cal_hash(input_string):\n    \&quot;\&quot;\&quot;\n    计算哈希值：使用特定算法计算字符串的哈希值，用于请求校验\n    这是从微信读书前端JS逆向得到的算法\n    参数:\n        input_string: 需要计算哈希的字符串\n    返回:\n        计算后的哈希值（十六进制字符串）\n    \&quot;\&quot;\&quot;\n    _7032f5 = 0x15051505  # 初始化第一个哈希值\n    _cc1055 = _7032f5     # 初始化第二个哈希值\n    length = len(input_string)  # 获取输入字符串长度\n    _19094e = length - 1  # 从字符串末尾开始\n\n    # 循环处理字符串中的每对字符\n    while _19094e &gt; 0:\n        # 对第一个哈希值进行位运算\n        _7032f5 = 0x7fffffff &amp; (_7032f5 ^ ord(input_string[_19094e]) &lt;&lt; (length - _19094e) % 30)\n        # 对第二个哈希值进行位运算\n        _cc1055 = 0x7fffffff &amp; (_cc1055 ^ ord(input_string[_19094e - 1]) &lt;&lt; _19094e % 30)\n        _19094e -= 2  # 每次处理两个字符\n\n    # 返回两个哈希值相加后的十六进制表示（去掉0x前缀）\n    return hex(_7032f5 + _cc1055)[2:].lower()\n\ndef get_wr_skey():\n    \&quot;\&quot;\&quot;\n    刷新cookie密钥：获取新的wr_skey值\n    微信读书的cookie需要定期刷新，此函数负责获取新的密钥\n    返回:\n        成功返回新的wr_skey值，失败返回None\n    \&quot;\&quot;\&quot;\n    # 发送请求获取新的cookie\n    response = requests.post(RENEW_URL, headers=headers, cookies=cookies,\n                             data=json.dumps(COOKIE_DATA, separators=(',', ':')))\n    # 从响应头中提取wr_skey\n    for cookie in response.headers.get('Set-Cookie', '').split(';'):\n        if \&quot;wr_skey\&quot; in cookie:\n            return cookie.split('=')[-1][:8]  # 返回前8位\n    return None  # 如果没找到则返回None\n\ndef fix_no_synckey():\n    \&quot;\&quot;\&quot;\n    修复synckey缺失问题：通过请求章节信息接口\n    有时阅读请求会返回没有synckey的情况，需要通过此函数修复\n    \&quot;\&quot;\&quot;\n    # 发送请求获取章节信息，间接修复synckey\n    requests.post(FIX_SYNCKEY_URL, headers=headers, cookies=cookies,\n                             data=json.dumps({\&quot;bookIds\&quot;:[\&quot;3300060341\&quot;]}, separators=(',', ':')))\n\ndef refresh_cookie():\n    \&quot;\&quot;\&quot;\n    刷新cookie：获取并更新wr_skey\n    这是保持会话有效的关键函数\n    \&quot;\&quot;\&quot;\n    logging.info(f\&quot; 刷新cookie\&quot;)\n    new_skey = get_wr_skey()  # 获取新的skey\n    if new_skey:\n        # 更新cookies中的wr_skey\n        cookies['wr_skey'] = new_skey\n        logging.info(f\&quot;✅ 密钥刷新成功，新密钥：{new_skey}\&quot;)\n        logging.info(f\&quot; 重新本次阅读。\&quot;)\n    else:\n        # 获取失败，记录错误并推送通知\n        ERROR_CODE = \&quot;❌ 无法获取新密钥或者WXREAD_CURL_BASH配置有误，终止运行。\&quot;\n        logging.error(ERROR_CODE)\n        push(ERROR_CODE, PUSH_METHOD)  # 推送错误信息\n        raise Exception(ERROR_CODE)  # 抛出异常终止程序\n\n# 主程序开始执行\n\n# 首先刷新cookie确保有效\nrefresh_cookie()\n\n# 初始化计数器和时间\nindex = 1  # 阅读次数计数器\nlastTime = int(time.time()) - 30  # 上次阅读时间（初始为当前时间减30秒）\n\n# 循环执行阅读操作，直到达到设定的次数\nwhile index &lt;= READ_NUM:\n    # 移除旧的校验和\n    data.pop('s')\n    \n    # 随机选择书籍和章节，增加真实性\n    data['b'] = random.choice(book)  # 随机选择一本书\n    data['c'] = random.choice(chapter)  # 随机选择一个章节\n    \n    # 更新时间相关字段\n    thisTime = int(time.time())  # 当前时间戳（秒）\n    data['ct'] = thisTime  # 当前时间\n    data['rt'] = thisTime - lastTime  # 阅读时长\n    data['ts'] = int(thisTime * 1000) + random.randint(0, 1000)  # 毫秒级时间戳加随机数\n    data['rn'] = random.randint(0, 1000)  # 随机数\n    \n    # 生成安全签名\n    data['sg'] = hashlib.sha256(f\&quot;{data['ts']}{data['rn']}{KEY}\&quot;.encode()).hexdigest()\n    \n    # 计算校验和\n    data['s'] = cal_hash(encode_data(data))\n\n    # 记录日志\n    logging.info(f\&quot;⏱️ 尝试第 {index} 次阅读...\&quot;)\n    logging.info(f\&quot; data: {data}\&quot;)\n    \n    # 发送阅读请求\n    response = requests.post(READ_URL, headers=headers, cookies=cookies, data=json.dumps(data, separators=(',', ':')))\n    resData = response.json()  # 解析响应JSON\n    logging.info(f\&quot; response: {resData}\&quot;)\n\n    # 处理响应结果\n    if 'succ' in resData:  # 请求成功\n        if 'synckey' in resData:  # 有同步键，表示阅读成功\n            lastTime = thisTime  # 更新上次阅读时间\n            index += 1  # 计数器加1\n            time.sleep(30)  # 等待30秒，模拟真实阅读间隔\n            logging.info(f\&quot;✅ 阅读成功，阅读进度：{(index - 1) * 0.5} 分钟\&quot;)\n        else:\n            # 没有synckey，尝试修复\n            logging.warning(\&quot;❌ 无synckey, 尝试修复...\&quot;)\n            fix_no_synckey()\n    else:\n        # 请求失败，可能是cookie过期\n        logging.warning(\&quot;❌ cookie 已过期，尝试刷新...\&quot;)\n        refresh_cookie()  # 刷新cookie\n\n# 所有阅读完成\nlogging.info(\&quot; 阅读脚本已完成！\&quot;)\n\n# 如果配置了推送方法，则发送完成通知\nif PUSH_METHOD not in (None, ''):\n    logging.info(\&quot;⏱️ 开始推送...\&quot;)\n    push(f\&quot; 微信读书自动阅读完成！\\n⏱️ 阅读时长：{(index - 1) * 0.5}分钟。\&quot;, PUSH_METHOD)\n````\n\n````python path=config.py mode=EDIT\n# config.py - 配置文件\n# 功能：存储脚本运行所需的各种配置参数，包括阅读次数、推送设置、请求头和cookies等\n# 作者：findmover\n# 版本：5.0\n\nimport os\nimport re\n\n\&quot;\&quot;\&quot;\n可修改区域\n默认使用本地值如果不存在从环境变量中获取值\n这样设计便于在不同环境（本地、Docker、GitHub Actions）中灵活配置\n\&quot;\&quot;\&quot;\n\n# 阅读次数 默认40次/20分钟，每次阅读约30秒\nREAD_NUM = int(os.getenv('READ_NUM') or 40)\n\n# 推送相关配置\n# 需要推送时可选，可选pushplus、wxpusher、telegram\nPUSH_METHOD = \&quot;\&quot; or os.getenv('PUSH_METHOD')\n\n# pushplus推送时需填写的token\nPUSHPLUS_TOKEN = \&quot;\&quot; or os.getenv(\&quot;PUSHPLUS_TOKEN\&quot;)\n\n# telegram推送时需填写的bot token和chat id\nTELEGRAM_BOT_TOKEN = \&quot;\&quot; or os.getenv(\&quot;TELEGRAM_BOT_TOKEN\&quot;)\nTELEGRAM_CHAT_ID = \&quot;\&quot; or os.getenv(\&quot;TELEGRAM_CHAT_ID\&quot;)\n\n# wxpusher推送时需填写的token\nWXPUSHER_SPT = \&quot;\&quot; or os.getenv(\&quot;WXPUSHER_SPT\&quot;)\n\n# read接口的bash命令，本地部署时可对应替换headers、cookies\n# 从环境变量获取curl命令，用于提取headers和cookies\ncurl_str = os.getenv('WXREAD_CURL_BASH')\n\n# headers、cookies是一个省略模版，本地或者docker部署时对应替换\n# 这些是默认的cookies，如果提供了curl_str，将被覆盖\ncookies = {\n    'RK': 'oxEY1bTnXf',\n    'ptcz': '53e3b35a9486dd63c4d06430b05aa169402117fc407dc5cc9329b41e59f62e2b',\n    'pac_uid': '0_e63870bcecc18',\n    'iip': '0',\n    '_qimei_uuid42': '183070d3135100ee797b08bc922054dc3062834291',\n    'wr_avatar': 'https%3A%2F%2Fthirdwx.qlogo.cn%2Fmmopen%2Fvi_32%2FeEOpSbFh2Mb1bUxMW9Y3FRPfXwWvOLaNlsjWIkcKeeNg6vlVS5kOVuhNKGQ1M8zaggLqMPmpE5qIUdqEXlQgYg%2F132',\n    'wr_gender': '0',\n}\n\n# 默认请求头，如果提供了curl_str，将被覆盖\nheaders = {\n    'accept': 'application/json, text/plain, */*',\n    'accept-language': 'zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6,ko;q=0.5',\n    'baggage': 'sentry-environment=production,sentry-release=dev-1730698697208,sentry-public_key=ed67ed71f7804a038e898ba54bd66e44,sentry-trace_id=1ff5a0725f8841088b42f97109c45862',\n    'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36 Edg/131.0.0.0',\n}\n\n\n# 书籍ID列表，随机选择一本书进行阅读\n# 这些ID是通过抓包获取的，代表不同的书籍\nbook = [\n    \&quot;36d322f07186022636daa5e\&quot;,\&quot;6f932ec05dd9eb6f96f14b9\&quot;,\&quot;43f3229071984b9343f04a4\&quot;,\&quot;d7732ea0813ab7d58g0184b8\&quot;,\n    \&quot;3d03298058a9443d052d409\&quot;,\&quot;4fc328a0729350754fc56d4\&quot;,\&quot;a743220058a92aa746632c0\&quot;,\&quot;140329d0716ce81f140468e\&quot;,\n    \&quot;1d9321c0718ff5e11d9afe8\&quot;,\&quot;ff132750727dc0f6ff1f7b5\&quot;,\&quot;e8532a40719c4eb7e851cbe\&quot;,\&quot;9b13257072562b5c9b1c8d6\&quot;\n]\n\n# 章节ID列表，随机选择一个章节进行阅读\n# 这些ID是通过抓包获取的，代表不同的章节\nchapter = [\n    \&quot;ecc32f3013eccbc87e4b62e\&quot;,\&quot;a87322c014a87ff679a21ea\&quot;,\&quot;e4d32d5015e4da3b7fbb1fa\&quot;,\&quot;16732dc0161679091c5aeb1\&quot;,\n    \&quot;8f132430178f14e45fce0f7\&quot;,\&quot;c9f326d018c9f0f895fb5e4\&quot;,\&quot;45c322601945c48cce2e120\&quot;,\&quot;d3d322001ad3d9446802347\&quot;,\n    \&quot;65132ca01b6512bd43d90e3\&quot;,\&quot;c20321001cc20ad4d76f5ae\&quot;,\&quot;c51323901dc51ce410c121b\&quot;,\&quot;aab325601eaab3238922e53\&quot;,\n    \&quot;9bf32f301f9bf31c7ff0a60\&quot;,\&quot;c7432af0210c74d97b01b1c\&quot;,\&quot;70e32fb021170efdf2eca12\&quot;,\&quot;6f4322302126f4922f45dec\&quot;\n]\n\n\&quot;\&quot;\&quot;\n建议保留区域|默认读三体，其它书籍自行测试时间是否增加\n这部分包含了请求所需的基本参数，通过逆向分析获得\n\&quot;\&quot;\&quot;\ndata = {\n    \&quot;appId\&quot;: \&quot;wb182564874603h266381671\&quot;,  # 应用ID\n    \&quot;b\&quot;: \&quot;ce032b305a9bc1ce0b0dd2a\&quot;,       # 书籍ID，会被随机替换\n    \&quot;c\&quot;: \&quot;7f632b502707f6ffaa6bf2e\&quot;,       # 章节ID，会被随机替换\n    \&quot;ci\&quot;: 27,                             # 章节索引\n    \&quot;co\&quot;: 389,                            # 内容位置\n    \&quot;sm\&quot;: \&quot;19聚会《三体》网友的聚会地点是一处僻静\&quot;,  # 内容摘要\n    \&quot;pr\&quot;: 74,                             # 页码或进度\n    \&quot;rt\&quot;: 15,                             # 阅读时长\n    \&quot;ts\&quot;: 1744264311434,                  # 时间戳（毫秒）\n    \&quot;rn\&quot;: 466,                            # 随机数\n    \&quot;sg\&quot;: \&quot;2b2ec618394b99deea35104168b86381da9f8946d4bc234e062fa320155409fb\&quot;,  # 安全签名\n    \&quot;ct\&quot;: 1744264311,                     # 时间戳（秒）\n    \&quot;ps\&quot;: \&quot;4ee326507a65a465g015fae\&quot;,      # 用户标识\n    \&quot;pc\&quot;: \&quot;aab32e207a65a466g010615\&quot;,      # 设备标识\n    \&quot;s\&quot;: \&quot;36cc0815\&quot;                       # 校验和\n}\n\n\ndef convert(curl_command):\n    \&quot;\&quot;\&quot;\n    提取bash接口中的headers与cookies\n    支持 -H 'Cookie: xxx' 和 -b 'xxx' 两种方式的cookie提取\n    \n    参数:\n        curl_command: curl命令字符串\n    返回:\n        headers: 提取的请求头字典\n        cookies: 提取的cookies字典\n    \&quot;\&quot;\&quot;\n    # 提取 headers\n    headers_temp = {}\n    for match in re.findall(r\&quot;-H '([^:]+): ([^']+)'\&quot;, curl_command):\n        headers_temp[match[0]] = match[1]\n\n    # 提取 cookies\n    cookies = {}\n    \n    # 从 -H 'Cookie: xxx' 提取\n    cookie_header = next((v for k, v in headers_temp.items() \n                         if k.lower() == 'cookie'), '')\n    \n    # 从 -b 'xxx' 提取\n    cookie_b = re.search(r\&quot;-b '([^']+)'\&quot;, curl_command)\n    cookie_string = cookie_b.group(1) if cookie_b else cookie_header\n    \n    # 解析 cookie 字符串\n    if cookie_string:\n        for cookie in cookie_string.split('; '):\n            if '=' in cookie:\n                key, value = cookie.split('=', 1)\n                cookies[key.strip()] = value.strip()\n    \n    # 移除 headers 中的 Cookie/cookie\n    headers = {k: v for k, v in headers_temp.items() \n              if k.lower() != 'cookie'}\n\n    return headers, cookies\n\n\n# 如果提供了curl命令，则从中提取headers和cookies，否则使用默认值\nheaders, cookies = convert(curl_str) if curl_str else (headers, cookies)\n````\n\n````python path=push.py mode=EDIT\n# push.py - 消息推送模块\n# 功能：支持多种推送方式（PushPlus、wxpusher、Telegram）发送通知消息\n# 作者：findmover\n# 版本：5.0\n\nimport os\nimport random\nimport time\nimport json\nimport requests\nimport logging\nfrom config import PUSHPLUS_TOKEN, TELEGRAM_CHAT_ID, TELEGRAM_BOT_TOKEN, WXPUSHER_SPT\n\n# 获取logger实例\nlogger = logging.getLogger(__name__)\n\n\nclass PushNotification:\n    \&quot;\&quot;\&quot;\n    推送通知类：封装了多种推送方式的实现\n    支持PushPlus、Telegram和WxPusher三种推送渠道\n    \&quot;\&quot;\&quot;\n    \n    def __init__(self):\n        \&quot;\&quot;\&quot;初始化推送通知类，设置各推送渠道的URL和请求头\&quot;\&quot;\&quot;\n        self.pushplus_url = \&quot;https://www.pushplus.plus/send\&quot;  # PushPlus推送API\n        self.telegram_url = \&quot;https://api.telegram.org/bot{}/sendMessage\&quot;  # Telegram API\n        self.headers = {'Content-Type': 'application/json'}  # 通用请求头\n        \n        # 从环境变量获取代理设置，用于Telegram推送\n        self.proxies = {\n            'http': os.getenv('http_proxy'),\n            'https': os.getenv('https_proxy')\n        }\n        \n        # WxPusher简易推送URL\n        self.wxpusher_simple_url = \&quot;https://wxpusher.zjiecode.com/api/send/message/{}/{}\&quot;\n\n    def push_pushplus(self, content, token):\n        \&quot;\&quot;\&quot;\n        PushPlus消息推送\n        \n        参数:\n            content: 推送内容\n            token: PushPlus的token\n        \&quot;\&quot;\&quot;\n        attempts = 5  # 最大尝试次数\n        for attempt in range(attempts):\n            try:\n                # 发送POST请求到PushPlus\n                response = requests.post(\n                    self.pushplus_url,\n                    data=json.dumps({\n                        \&quot;token\&quot;: token,\n                        \&quot;title\&quot;: \&quot;微信阅读推送...\&quot;,\n                        \&quot;content\&quot;: content\n                    }).encode('utf-8'),\n                    headers=self.headers,\n                    timeout=10\n                )\n                response.raise_for_status()  # 检查响应状态\n                logger.info(\&quot;✅ PushPlus响应: %s\&quot;, response.text)\n                break  # 成功推送，跳出循环\n            except requests.exceptions.RequestException as e:\n                logger.error(\&quot;❌ PushPlus推送失败: %s\&quot;, e)\n                if attempt &lt; attempts - 1:  # 如果不是最后一次尝试\n                    sleep_time = random.randint(180, 360)  # 随机3到6分钟\n                    logger.info(\&quot;将在 %d 秒后重试...\&quot;, sleep_time)\n                    time.sleep(sleep_time)  # 等待一段时间后重试\n\n    def push_telegram(self, content, bot_token, chat_id):\n        \&quot;\&quot;\&quot;\n        Telegram消息推送，失败时自动尝试直连\n        \n        参数:\n            content: 推送内容\n            bot_token: Telegram机器人token\n            chat_id: 聊天ID\n            \n        返回:\n            bool: 推送成功返回True，否则返回False\n        \&quot;\&quot;\&quot;\n        url = self.telegram_url.format(bot_token)  # 格式化URL\n        payload = {\&quot;chat_id\&quot;: chat_id, \&quot;text\&quot;: content}  # 请求数据\n\n        try:\n            # 先尝试使用代理\n            response = requests.post(url, json=payload, proxies=self.proxies, timeout=30)\n            logger.info(\&quot;✅ Telegram响应: %s\&quot;, response.text)\n            response.raise_for_status()\n            return True\n        except Exception as e:\n            logger.error(\&quot;❌ Telegram代理发送失败: %s\&quot;, e)\n            try:\n                # 代理失败后直连\n                response = requests.post(url, json=payload, timeout=30)\n                response.raise_for_status()\n                return True\n            except Exception as e:\n                logger.error(\&quot;❌ Telegram发送失败: %s\&quot;, e)\n                return False\n    \n    def push_wxpusher(self, content, spt):\n        \&quot;\&quot;\&quot;\n        WxPusher消息推送（极简方式）\n        \n        参数:\n            content: 推送内容\n            spt: WxPusher的SPT参数\n        \&quot;\&quot;\&quot;\n        attempts = 5  # 最大尝试次数\n        url = self.wxpusher_simple_url.format(spt, content)  # 格式化URL\n        \n        for attempt in range(attempts):\n            try:\n                # 发送GET请求到WxPusher\n                response = requests.get(url, timeout=10)\n                response.raise_for_status()  # 检查响应状态\n                logger.info(\&quot;✅ WxPusher响应: %s\&quot;, response.text)\n                break  # 成功推送，跳出循环\n            except requests.exceptions.RequestException as e:\n                logger.error(\&quot;❌ WxPusher推送失败: %s\&quot;, e)\n                if attempt &lt; attempts - 1:  # 如果不是最后一次尝试\n                    sleep_time = random.randint(180, 360)  # 随机3到6分钟\n                    logger.info(\&quot;将在 %d 秒后重试...\&quot;, sleep_time)\n                    time.sleep(sleep_time)  # 等待一段时间后重试\n\n\n\&quot;\&quot;\&quot;外部调用接口\&quot;\&quot;\&quot;\n\n\ndef push(content, method):\n    \&quot;\&quot;\&quot;\n    统一推送接口，支持多种推送方式\n    \n    参数:\n        content: 推送内容\n        method: 推送方式，支持'pushplus'、'telegram'和'wxpusher'\n        \n    返回:\n        根据不同推送方式返回相应结果\n        \n    异常:\n        ValueError: 当提供的推送方式无效时抛出\n    \&quot;\&quot;\&quot;\n    notifier = PushNotification()  # 创建推送通知实例\n\n    if method == \&quot;pushplus\&quot;:\n        token = PUSHPLUS_TOKEN\n        return notifier.push_pushplus(content, token)\n    elif method == \&quot;telegram\&quot;:\n        bot_token = TELEGRAM_BOT_TOKEN\n        chat_id = TELEGRAM_CHAT_ID\n        return notifier.push_telegram(content, bot_token, chat_id)\n    elif method == \&quot;wxpusher\&quot;:\n        return notifier.push_wxpusher(content, WXPUSHER_SPT)\n    else:\n        raise ValueError(\&quot;❌ 无效的通知渠道，请选择 'pushplus'、'telegram' 或 'wxpusher'\&quot;)\n````\n\n````yaml path=.github/workflows/deploy.yml mode=EDIT\n# deploy.yml - GitHub Actions工作流配置文件\n# 功能：定义自动化工作流，定时或手动触发微信读书自动阅读脚本\n# 作者：findmover\n# 版本：5.0\n\nname: wxread  # 工作流名称\n\non:\n  schedule:\n    # 定时触发配置\n    # 凌晨任务：北京时间每天 01:00（UTC 前一天 17:00）\n    - cron: '0 17 * * *'\n    # 早间任务：北京时间每天 05:00（UTC 前一天 21:00）\n    #- cron: '0 21 * * *'\n    # 午间任务：北京时间每天 11:40（UTC 03:40）\n    #- cron: '40 3 * * *'\n    # 晚间任务：北京时间每天 22:00（UTC 14:00）\n    #- cron: '0 14 * * *'\n  workflow_dispatch:  # 允许手动触发工作流\n\njobs:\n  deploy:\n    runs-on: ubuntu-22.04  # 指定运行环境\n    environment: AutoRead  # 指定GitHub环境，用于存储敏感信息\n\n    steps:\n    # 设置DNS为Google的DNS服务器，避免DNS解析问题\n    - name: Set DNS to Google's DNS\n      run: |\n        echo \&quot;nameserver 8.8.8.8\&quot; | sudo tee /etc/resolv.conf\n        echo \&quot;nameserver 8.8.4.4\&quot; | sudo tee -a /etc/resolv.conf\n\n    # 检出代码仓库\n    - name: Checkout repository\n      uses: actions/checkout@v2\n\n    # 设置Python环境\n    - name: Set up Python\n      uses: actions/setup-python@v2\n      with:\n        python-version: '3.10'  # 指定Python版本\n\n    # 安装依赖包\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install certifi==2024.8.30 charset-normalizer==3.4.0 idna==3.10 requests==2.32.3 urllib3==2.2.3\n\n    # 运行脚本\n    - name: Run deployment script\n      env:\n        # 设置环境变量，从GitHub Secrets和Variables获取\n        WXREAD_CURL_BASH: ${{ secrets.WXREAD_CURL_BASH }}  # 微信读书curl命令\n        PUSH_METHOD: ${{ secrets.PUSH_METHOD }}  # 推送方式\n        PUSHPLUS_TOKEN: ${{ secrets.PUSHPLUS_TOKEN }}  # PushPlus token\n        WXPUSHER_SPT: ${{ secrets.WXPUSHER_SPT }}  # WxPusher token\n        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}  # Telegram bot token\n        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}  # Telegram chat ID\n        READ_NUM: ${{ vars.READ_NUM }}  # 阅读次数，使用Repository Variables\n\n      run: |\n        python main.py  # 执行主脚本\n````\n\n````dockerfile path=Dockerfile mode=EDIT\n# Dockerfile - Docker容器配置文件\n# 功能：定义Docker镜像构建过程，用于在容器中运行微信读书自动阅读脚本\n# 作者：findmover\n# 版本：5.0\n\n# 使用Python 3.10精简版作为基础镜像\nFROM python:3.10-slim\n\n# 设置工作目录\nWORKDIR /app\n\n# 设置时区为中国时区，确保日志时间正确\nENV TZ=Asia/Shanghai\nRUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone\n\n# 安装 cron 定时任务工具\n# 更新apt源并安装cron，安装完成后清理apt缓存减小镜像体积\nRUN apt-get update &amp;&amp; apt-get install -y cron &amp;&amp; rm -rf /var/lib/apt/lists/*\nENV PATH=\&quot;/usr/local/bin:${PATH}\&quot;  # 确保Python\n````\n&quot;},{&quot;id&quot;:3,&quot;type&quot;:3,&quot;content&quot;:&quot;Dockerfile:0-776\nconfig.py:0-583\nconfig.py:583-1047\nconfig.py:1047-1524\nconfig.py:1524-1869\nconfig.py:1869-2324\nconfig.py:2324-2810\nconfig.py:2810-3644\nconfig.py:3644-3881\nmain.py:0-646\nmain.py:646-1215\nmain.py:1215-1763\nmain.py:1763-2165\nmain.py:2165-2947\nmain.py:2947-3496\n.github/workflows/deploy.yml:0-310\n.github/workflows/deploy.yml:310-946\n.github/workflows/deploy.yml:946-1425\npush.py:0-734\npush.py:734-1752\npush.py:1752-2589\npush.py:2589-3324\npush.py:3324-3915\nREADME.md:0-758\nREADME.md:758-1212\nREADME.md:1212-1885\nREADME.md:1885-2639\nREADME.md:2639-3365\nREADME.md:3365-3557\nREADME.md:3557-4309\nREADME.md:4309-4358\n.gitignore:0-65\n.vscode/settings.json:0-39&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:0,&quot;type&quot;:0,&quot;text_node&quot;:{&quot;content&quot;:&quot;添加整个仓库代码的每个 .py、.yml、Dockerfile 文件添加全量注释, 详细说明代码的的作用&quot;}},{&quot;id&quot;:1,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;D:/130__Work__Python/wxread&quot;,&quot;folderRoot&quot;:&quot;D:/130__Work__Python/wxread&quot;}],&quot;workspaceFoldersUnchanged&quot;:false}}],&quot;timestamp&quot;:&quot;2025-07-09T16:14:27.490Z&quot;,&quot;response_text&quot;:&quot;我将为仓库中的每个主要文件添加详细注释。让我们从每个文件开始：\n\n````python path=main.py mode=EDIT\n# main.py - 主逻辑文件\n# 功能：实现微信读书自动阅读功能，包括请求构建、加密签名生成、自动刷新cookie等核心功能\n# 作者：findmover\n# 版本：5.0\n\nimport re\nimport json\nimport time\nimport random\nimport logging\nimport hashlib\nimport requests\nimport urllib.parse\nfrom push import push  # 导入推送模块，用于发送通知\nfrom config import data, headers, cookies, READ_NUM, PUSH_METHOD, book, chapter  # 导入配置信息\n\n# 配置日志格式，便于调试和查看运行状态\nlogger = logging.getLogger(__name__)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)-8s - %(message)s')\n\n# 关键常量定义\nKEY = \&quot;3c5c8717f3daf09iop3423zafeqoi\&quot;  # 用于生成安全签名的密钥，通过逆向JS获得\nCOOKIE_DATA = {\&quot;rq\&quot;: \&quot;%2Fweb%2Fbook%2Fread\&quot;}  # 刷新cookie时的请求数据\nREAD_URL = \&quot;https://weread.qq.com/web/book/read\&quot;  # 微信读书阅读接口URL\nRENEW_URL = \&quot;https://weread.qq.com/web/login/renewal\&quot;  # 刷新token的URL\nFIX_SYNCKEY_URL = \&quot;https://weread.qq.com/web/book/chapterInfos\&quot;  # 修复synckey的URL\n\n\ndef encode_data(data):\n    \&quot;\&quot;\&quot;\n    数据编码函数：将字典转换为URL编码的字符串，并按键名排序\n    参数:\n        data: 包含请求参数的字典\n    返回:\n        按键名排序并URL编码后的字符串\n    \&quot;\&quot;\&quot;\n    return '&amp;'.join(f\&quot;{k}={urllib.parse.quote(str(data[k]), safe='')}\&quot; for k in sorted(data.keys()))\n\n\ndef cal_hash(input_string):\n    \&quot;\&quot;\&quot;\n    计算哈希值：使用特定算法计算字符串的哈希值，用于请求校验\n    这是从微信读书前端JS逆向得到的算法\n    参数:\n        input_string: 需要计算哈希的字符串\n    返回:\n        计算后的哈希值（十六进制字符串）\n    \&quot;\&quot;\&quot;\n    _7032f5 = 0x15051505  # 初始化第一个哈希值\n    _cc1055 = _7032f5     # 初始化第二个哈希值\n    length = len(input_string)  # 获取输入字符串长度\n    _19094e = length - 1  # 从字符串末尾开始\n\n    # 循环处理字符串中的每对字符\n    while _19094e &gt; 0:\n        # 对第一个哈希值进行位运算\n        _7032f5 = 0x7fffffff &amp; (_7032f5 ^ ord(input_string[_19094e]) &lt;&lt; (length - _19094e) % 30)\n        # 对第二个哈希值进行位运算\n        _cc1055 = 0x7fffffff &amp; (_cc1055 ^ ord(input_string[_19094e - 1]) &lt;&lt; _19094e % 30)\n        _19094e -= 2  # 每次处理两个字符\n\n    # 返回两个哈希值相加后的十六进制表示（去掉0x前缀）\n    return hex(_7032f5 + _cc1055)[2:].lower()\n\ndef get_wr_skey():\n    \&quot;\&quot;\&quot;\n    刷新cookie密钥：获取新的wr_skey值\n    微信读书的cookie需要定期刷新，此函数负责获取新的密钥\n    返回:\n        成功返回新的wr_skey值，失败返回None\n    \&quot;\&quot;\&quot;\n    # 发送请求获取新的cookie\n    response = requests.post(RENEW_URL, headers=headers, cookies=cookies,\n                             data=json.dumps(COOKIE_DATA, separators=(',', ':')))\n    # 从响应头中提取wr_skey\n    for cookie in response.headers.get('Set-Cookie', '').split(';'):\n        if \&quot;wr_skey\&quot; in cookie:\n            return cookie.split('=')[-1][:8]  # 返回前8位\n    return None  # 如果没找到则返回None\n\ndef fix_no_synckey():\n    \&quot;\&quot;\&quot;\n    修复synckey缺失问题：通过请求章节信息接口\n    有时阅读请求会返回没有synckey的情况，需要通过此函数修复\n    \&quot;\&quot;\&quot;\n    # 发送请求获取章节信息，间接修复synckey\n    requests.post(FIX_SYNCKEY_URL, headers=headers, cookies=cookies,\n                             data=json.dumps({\&quot;bookIds\&quot;:[\&quot;3300060341\&quot;]}, separators=(',', ':')))\n\ndef refresh_cookie():\n    \&quot;\&quot;\&quot;\n    刷新cookie：获取并更新wr_skey\n    这是保持会话有效的关键函数\n    \&quot;\&quot;\&quot;\n    logging.info(f\&quot; 刷新cookie\&quot;)\n    new_skey = get_wr_skey()  # 获取新的skey\n    if new_skey:\n        # 更新cookies中的wr_skey\n        cookies['wr_skey'] = new_skey\n        logging.info(f\&quot;✅ 密钥刷新成功，新密钥：{new_skey}\&quot;)\n        logging.info(f\&quot; 重新本次阅读。\&quot;)\n    else:\n        # 获取失败，记录错误并推送通知\n        ERROR_CODE = \&quot;❌ 无法获取新密钥或者WXREAD_CURL_BASH配置有误，终止运行。\&quot;\n        logging.error(ERROR_CODE)\n        push(ERROR_CODE, PUSH_METHOD)  # 推送错误信息\n        raise Exception(ERROR_CODE)  # 抛出异常终止程序\n\n# 主程序开始执行\n\n# 首先刷新cookie确保有效\nrefresh_cookie()\n\n# 初始化计数器和时间\nindex = 1  # 阅读次数计数器\nlastTime = int(time.time()) - 30  # 上次阅读时间（初始为当前时间减30秒）\n\n# 循环执行阅读操作，直到达到设定的次数\nwhile index &lt;= READ_NUM:\n    # 移除旧的校验和\n    data.pop('s')\n    \n    # 随机选择书籍和章节，增加真实性\n    data['b'] = random.choice(book)  # 随机选择一本书\n    data['c'] = random.choice(chapter)  # 随机选择一个章节\n    \n    # 更新时间相关字段\n    thisTime = int(time.time())  # 当前时间戳（秒）\n    data['ct'] = thisTime  # 当前时间\n    data['rt'] = thisTime - lastTime  # 阅读时长\n    data['ts'] = int(thisTime * 1000) + random.randint(0, 1000)  # 毫秒级时间戳加随机数\n    data['rn'] = random.randint(0, 1000)  # 随机数\n    \n    # 生成安全签名\n    data['sg'] = hashlib.sha256(f\&quot;{data['ts']}{data['rn']}{KEY}\&quot;.encode()).hexdigest()\n    \n    # 计算校验和\n    data['s'] = cal_hash(encode_data(data))\n\n    # 记录日志\n    logging.info(f\&quot;⏱️ 尝试第 {index} 次阅读...\&quot;)\n    logging.info(f\&quot; data: {data}\&quot;)\n    \n    # 发送阅读请求\n    response = requests.post(READ_URL, headers=headers, cookies=cookies, data=json.dumps(data, separators=(',', ':')))\n    resData = response.json()  # 解析响应JSON\n    logging.info(f\&quot; response: {resData}\&quot;)\n\n    # 处理响应结果\n    if 'succ' in resData:  # 请求成功\n        if 'synckey' in resData:  # 有同步键，表示阅读成功\n            lastTime = thisTime  # 更新上次阅读时间\n            index += 1  # 计数器加1\n            time.sleep(30)  # 等待30秒，模拟真实阅读间隔\n            logging.info(f\&quot;✅ 阅读成功，阅读进度：{(index - 1) * 0.5} 分钟\&quot;)\n        else:\n            # 没有synckey，尝试修复\n            logging.warning(\&quot;❌ 无synckey, 尝试修复...\&quot;)\n            fix_no_synckey()\n    else:\n        # 请求失败，可能是cookie过期\n        logging.warning(\&quot;❌ cookie 已过期，尝试刷新...\&quot;)\n        refresh_cookie()  # 刷新cookie\n\n# 所有阅读完成\nlogging.info(\&quot; 阅读脚本已完成！\&quot;)\n\n# 如果配置了推送方法，则发送完成通知\nif PUSH_METHOD not in (None, ''):\n    logging.info(\&quot;⏱️ 开始推送...\&quot;)\n    push(f\&quot; 微信读书自动阅读完成！\\n⏱️ 阅读时长：{(index - 1) * 0.5}分钟。\&quot;, PUSH_METHOD)\n````\n\n````python path=config.py mode=EDIT\n# config.py - 配置文件\n# 功能：存储脚本运行所需的各种配置参数，包括阅读次数、推送设置、请求头和cookies等\n# 作者：findmover\n# 版本：5.0\n\nimport os\nimport re\n\n\&quot;\&quot;\&quot;\n可修改区域\n默认使用本地值如果不存在从环境变量中获取值\n这样设计便于在不同环境（本地、Docker、GitHub Actions）中灵活配置\n\&quot;\&quot;\&quot;\n\n# 阅读次数 默认40次/20分钟，每次阅读约30秒\nREAD_NUM = int(os.getenv('READ_NUM') or 40)\n\n# 推送相关配置\n# 需要推送时可选，可选pushplus、wxpusher、telegram\nPUSH_METHOD = \&quot;\&quot; or os.getenv('PUSH_METHOD')\n\n# pushplus推送时需填写的token\nPUSHPLUS_TOKEN = \&quot;\&quot; or os.getenv(\&quot;PUSHPLUS_TOKEN\&quot;)\n\n# telegram推送时需填写的bot token和chat id\nTELEGRAM_BOT_TOKEN = \&quot;\&quot; or os.getenv(\&quot;TELEGRAM_BOT_TOKEN\&quot;)\nTELEGRAM_CHAT_ID = \&quot;\&quot; or os.getenv(\&quot;TELEGRAM_CHAT_ID\&quot;)\n\n# wxpusher推送时需填写的token\nWXPUSHER_SPT = \&quot;\&quot; or os.getenv(\&quot;WXPUSHER_SPT\&quot;)\n\n# read接口的bash命令，本地部署时可对应替换headers、cookies\n# 从环境变量获取curl命令，用于提取headers和cookies\ncurl_str = os.getenv('WXREAD_CURL_BASH')\n\n# headers、cookies是一个省略模版，本地或者docker部署时对应替换\n# 这些是默认的cookies，如果提供了curl_str，将被覆盖\ncookies = {\n    'RK': 'oxEY1bTnXf',\n    'ptcz': '53e3b35a9486dd63c4d06430b05aa169402117fc407dc5cc9329b41e59f62e2b',\n    'pac_uid': '0_e63870bcecc18',\n    'iip': '0',\n    '_qimei_uuid42': '183070d3135100ee797b08bc922054dc3062834291',\n    'wr_avatar': 'https%3A%2F%2Fthirdwx.qlogo.cn%2Fmmopen%2Fvi_32%2FeEOpSbFh2Mb1bUxMW9Y3FRPfXwWvOLaNlsjWIkcKeeNg6vlVS5kOVuhNKGQ1M8zaggLqMPmpE5qIUdqEXlQgYg%2F132',\n    'wr_gender': '0',\n}\n\n# 默认请求头，如果提供了curl_str，将被覆盖\nheaders = {\n    'accept': 'application/json, text/plain, */*',\n    'accept-language': 'zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6,ko;q=0.5',\n    'baggage': 'sentry-environment=production,sentry-release=dev-1730698697208,sentry-public_key=ed67ed71f7804a038e898ba54bd66e44,sentry-trace_id=1ff5a0725f8841088b42f97109c45862',\n    'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36 Edg/131.0.0.0',\n}\n\n\n# 书籍ID列表，随机选择一本书进行阅读\n# 这些ID是通过抓包获取的，代表不同的书籍\nbook = [\n    \&quot;36d322f07186022636daa5e\&quot;,\&quot;6f932ec05dd9eb6f96f14b9\&quot;,\&quot;43f3229071984b9343f04a4\&quot;,\&quot;d7732ea0813ab7d58g0184b8\&quot;,\n    \&quot;3d03298058a9443d052d409\&quot;,\&quot;4fc328a0729350754fc56d4\&quot;,\&quot;a743220058a92aa746632c0\&quot;,\&quot;140329d0716ce81f140468e\&quot;,\n    \&quot;1d9321c0718ff5e11d9afe8\&quot;,\&quot;ff132750727dc0f6ff1f7b5\&quot;,\&quot;e8532a40719c4eb7e851cbe\&quot;,\&quot;9b13257072562b5c9b1c8d6\&quot;\n]\n\n# 章节ID列表，随机选择一个章节进行阅读\n# 这些ID是通过抓包获取的，代表不同的章节\nchapter = [\n    \&quot;ecc32f3013eccbc87e4b62e\&quot;,\&quot;a87322c014a87ff679a21ea\&quot;,\&quot;e4d32d5015e4da3b7fbb1fa\&quot;,\&quot;16732dc0161679091c5aeb1\&quot;,\n    \&quot;8f132430178f14e45fce0f7\&quot;,\&quot;c9f326d018c9f0f895fb5e4\&quot;,\&quot;45c322601945c48cce2e120\&quot;,\&quot;d3d322001ad3d9446802347\&quot;,\n    \&quot;65132ca01b6512bd43d90e3\&quot;,\&quot;c20321001cc20ad4d76f5ae\&quot;,\&quot;c51323901dc51ce410c121b\&quot;,\&quot;aab325601eaab3238922e53\&quot;,\n    \&quot;9bf32f301f9bf31c7ff0a60\&quot;,\&quot;c7432af0210c74d97b01b1c\&quot;,\&quot;70e32fb021170efdf2eca12\&quot;,\&quot;6f4322302126f4922f45dec\&quot;\n]\n\n\&quot;\&quot;\&quot;\n建议保留区域|默认读三体，其它书籍自行测试时间是否增加\n这部分包含了请求所需的基本参数，通过逆向分析获得\n\&quot;\&quot;\&quot;\ndata = {\n    \&quot;appId\&quot;: \&quot;wb182564874603h266381671\&quot;,  # 应用ID\n    \&quot;b\&quot;: \&quot;ce032b305a9bc1ce0b0dd2a\&quot;,       # 书籍ID，会被随机替换\n    \&quot;c\&quot;: \&quot;7f632b502707f6ffaa6bf2e\&quot;,       # 章节ID，会被随机替换\n    \&quot;ci\&quot;: 27,                             # 章节索引\n    \&quot;co\&quot;: 389,                            # 内容位置\n    \&quot;sm\&quot;: \&quot;19聚会《三体》网友的聚会地点是一处僻静\&quot;,  # 内容摘要\n    \&quot;pr\&quot;: 74,                             # 页码或进度\n    \&quot;rt\&quot;: 15,                             # 阅读时长\n    \&quot;ts\&quot;: 1744264311434,                  # 时间戳（毫秒）\n    \&quot;rn\&quot;: 466,                            # 随机数\n    \&quot;sg\&quot;: \&quot;2b2ec618394b99deea35104168b86381da9f8946d4bc234e062fa320155409fb\&quot;,  # 安全签名\n    \&quot;ct\&quot;: 1744264311,                     # 时间戳（秒）\n    \&quot;ps\&quot;: \&quot;4ee326507a65a465g015fae\&quot;,      # 用户标识\n    \&quot;pc\&quot;: \&quot;aab32e207a65a466g010615\&quot;,      # 设备标识\n    \&quot;s\&quot;: \&quot;36cc0815\&quot;                       # 校验和\n}\n\n\ndef convert(curl_command):\n    \&quot;\&quot;\&quot;\n    提取bash接口中的headers与cookies\n    支持 -H 'Cookie: xxx' 和 -b 'xxx' 两种方式的cookie提取\n    \n    参数:\n        curl_command: curl命令字符串\n    返回:\n        headers: 提取的请求头字典\n        cookies: 提取的cookies字典\n    \&quot;\&quot;\&quot;\n    # 提取 headers\n    headers_temp = {}\n    for match in re.findall(r\&quot;-H '([^:]+): ([^']+)'\&quot;, curl_command):\n        headers_temp[match[0]] = match[1]\n\n    # 提取 cookies\n    cookies = {}\n    \n    # 从 -H 'Cookie: xxx' 提取\n    cookie_header = next((v for k, v in headers_temp.items() \n                         if k.lower() == 'cookie'), '')\n    \n    # 从 -b 'xxx' 提取\n    cookie_b = re.search(r\&quot;-b '([^']+)'\&quot;, curl_command)\n    cookie_string = cookie_b.group(1) if cookie_b else cookie_header\n    \n    # 解析 cookie 字符串\n    if cookie_string:\n        for cookie in cookie_string.split('; '):\n            if '=' in cookie:\n                key, value = cookie.split('=', 1)\n                cookies[key.strip()] = value.strip()\n    \n    # 移除 headers 中的 Cookie/cookie\n    headers = {k: v for k, v in headers_temp.items() \n              if k.lower() != 'cookie'}\n\n    return headers, cookies\n\n\n# 如果提供了curl命令，则从中提取headers和cookies，否则使用默认值\nheaders, cookies = convert(curl_str) if curl_str else (headers, cookies)\n````\n\n````python path=push.py mode=EDIT\n# push.py - 消息推送模块\n# 功能：支持多种推送方式（PushPlus、wxpusher、Telegram）发送通知消息\n# 作者：findmover\n# 版本：5.0\n\nimport os\nimport random\nimport time\nimport json\nimport requests\nimport logging\nfrom config import PUSHPLUS_TOKEN, TELEGRAM_CHAT_ID, TELEGRAM_BOT_TOKEN, WXPUSHER_SPT\n\n# 获取logger实例\nlogger = logging.getLogger(__name__)\n\n\nclass PushNotification:\n    \&quot;\&quot;\&quot;\n    推送通知类：封装了多种推送方式的实现\n    支持PushPlus、Telegram和WxPusher三种推送渠道\n    \&quot;\&quot;\&quot;\n    \n    def __init__(self):\n        \&quot;\&quot;\&quot;初始化推送通知类，设置各推送渠道的URL和请求头\&quot;\&quot;\&quot;\n        self.pushplus_url = \&quot;https://www.pushplus.plus/send\&quot;  # PushPlus推送API\n        self.telegram_url = \&quot;https://api.telegram.org/bot{}/sendMessage\&quot;  # Telegram API\n        self.headers = {'Content-Type': 'application/json'}  # 通用请求头\n        \n        # 从环境变量获取代理设置，用于Telegram推送\n        self.proxies = {\n            'http': os.getenv('http_proxy'),\n            'https': os.getenv('https_proxy')\n        }\n        \n        # WxPusher简易推送URL\n        self.wxpusher_simple_url = \&quot;https://wxpusher.zjiecode.com/api/send/message/{}/{}\&quot;\n\n    def push_pushplus(self, content, token):\n        \&quot;\&quot;\&quot;\n        PushPlus消息推送\n        \n        参数:\n            content: 推送内容\n            token: PushPlus的token\n        \&quot;\&quot;\&quot;\n        attempts = 5  # 最大尝试次数\n        for attempt in range(attempts):\n            try:\n                # 发送POST请求到PushPlus\n                response = requests.post(\n                    self.pushplus_url,\n                    data=json.dumps({\n                        \&quot;token\&quot;: token,\n                        \&quot;title\&quot;: \&quot;微信阅读推送...\&quot;,\n                        \&quot;content\&quot;: content\n                    }).encode('utf-8'),\n                    headers=self.headers,\n                    timeout=10\n                )\n                response.raise_for_status()  # 检查响应状态\n                logger.info(\&quot;✅ PushPlus响应: %s\&quot;, response.text)\n                break  # 成功推送，跳出循环\n            except requests.exceptions.RequestException as e:\n                logger.error(\&quot;❌ PushPlus推送失败: %s\&quot;, e)\n                if attempt &lt; attempts - 1:  # 如果不是最后一次尝试\n                    sleep_time = random.randint(180, 360)  # 随机3到6分钟\n                    logger.info(\&quot;将在 %d 秒后重试...\&quot;, sleep_time)\n                    time.sleep(sleep_time)  # 等待一段时间后重试\n\n    def push_telegram(self, content, bot_token, chat_id):\n        \&quot;\&quot;\&quot;\n        Telegram消息推送，失败时自动尝试直连\n        \n        参数:\n            content: 推送内容\n            bot_token: Telegram机器人token\n            chat_id: 聊天ID\n            \n        返回:\n            bool: 推送成功返回True，否则返回False\n        \&quot;\&quot;\&quot;\n        url = self.telegram_url.format(bot_token)  # 格式化URL\n        payload = {\&quot;chat_id\&quot;: chat_id, \&quot;text\&quot;: content}  # 请求数据\n\n        try:\n            # 先尝试使用代理\n            response = requests.post(url, json=payload, proxies=self.proxies, timeout=30)\n            logger.info(\&quot;✅ Telegram响应: %s\&quot;, response.text)\n            response.raise_for_status()\n            return True\n        except Exception as e:\n            logger.error(\&quot;❌ Telegram代理发送失败: %s\&quot;, e)\n            try:\n                # 代理失败后直连\n                response = requests.post(url, json=payload, timeout=30)\n                response.raise_for_status()\n                return True\n            except Exception as e:\n                logger.error(\&quot;❌ Telegram发送失败: %s\&quot;, e)\n                return False\n    \n    def push_wxpusher(self, content, spt):\n        \&quot;\&quot;\&quot;\n        WxPusher消息推送（极简方式）\n        \n        参数:\n            content: 推送内容\n            spt: WxPusher的SPT参数\n        \&quot;\&quot;\&quot;\n        attempts = 5  # 最大尝试次数\n        url = self.wxpusher_simple_url.format(spt, content)  # 格式化URL\n        \n        for attempt in range(attempts):\n            try:\n                # 发送GET请求到WxPusher\n                response = requests.get(url, timeout=10)\n                response.raise_for_status()  # 检查响应状态\n                logger.info(\&quot;✅ WxPusher响应: %s\&quot;, response.text)\n                break  # 成功推送，跳出循环\n            except requests.exceptions.RequestException as e:\n                logger.error(\&quot;❌ WxPusher推送失败: %s\&quot;, e)\n                if attempt &lt; attempts - 1:  # 如果不是最后一次尝试\n                    sleep_time = random.randint(180, 360)  # 随机3到6分钟\n                    logger.info(\&quot;将在 %d 秒后重试...\&quot;, sleep_time)\n                    time.sleep(sleep_time)  # 等待一段时间后重试\n\n\n\&quot;\&quot;\&quot;外部调用接口\&quot;\&quot;\&quot;\n\n\ndef push(content, method):\n    \&quot;\&quot;\&quot;\n    统一推送接口，支持多种推送方式\n    \n    参数:\n        content: 推送内容\n        method: 推送方式，支持'pushplus'、'telegram'和'wxpusher'\n        \n    返回:\n        根据不同推送方式返回相应结果\n        \n    异常:\n        ValueError: 当提供的推送方式无效时抛出\n    \&quot;\&quot;\&quot;\n    notifier = PushNotification()  # 创建推送通知实例\n\n    if method == \&quot;pushplus\&quot;:\n        token = PUSHPLUS_TOKEN\n        return notifier.push_pushplus(content, token)\n    elif method == \&quot;telegram\&quot;:\n        bot_token = TELEGRAM_BOT_TOKEN\n        chat_id = TELEGRAM_CHAT_ID\n        return notifier.push_telegram(content, bot_token, chat_id)\n    elif method == \&quot;wxpusher\&quot;:\n        return notifier.push_wxpusher(content, WXPUSHER_SPT)\n    else:\n        raise ValueError(\&quot;❌ 无效的通知渠道，请选择 'pushplus'、'telegram' 或 'wxpusher'\&quot;)\n````\n\n````yaml path=.github/workflows/deploy.yml mode=EDIT\n# deploy.yml - GitHub Actions工作流配置文件\n# 功能：定义自动化工作流，定时或手动触发微信读书自动阅读脚本\n# 作者：findmover\n# 版本：5.0\n\nname: wxread  # 工作流名称\n\non:\n  schedule:\n    # 定时触发配置\n    # 凌晨任务：北京时间每天 01:00（UTC 前一天 17:00）\n    - cron: '0 17 * * *'\n    # 早间任务：北京时间每天 05:00（UTC 前一天 21:00）\n    #- cron: '0 21 * * *'\n    # 午间任务：北京时间每天 11:40（UTC 03:40）\n    #- cron: '40 3 * * *'\n    # 晚间任务：北京时间每天 22:00（UTC 14:00）\n    #- cron: '0 14 * * *'\n  workflow_dispatch:  # 允许手动触发工作流\n\njobs:\n  deploy:\n    runs-on: ubuntu-22.04  # 指定运行环境\n    environment: AutoRead  # 指定GitHub环境，用于存储敏感信息\n\n    steps:\n    # 设置DNS为Google的DNS服务器，避免DNS解析问题\n    - name: Set DNS to Google's DNS\n      run: |\n        echo \&quot;nameserver 8.8.8.8\&quot; | sudo tee /etc/resolv.conf\n        echo \&quot;nameserver 8.8.4.4\&quot; | sudo tee -a /etc/resolv.conf\n\n    # 检出代码仓库\n    - name: Checkout repository\n      uses: actions/checkout@v2\n\n    # 设置Python环境\n    - name: Set up Python\n      uses: actions/setup-python@v2\n      with:\n        python-version: '3.10'  # 指定Python版本\n\n    # 安装依赖包\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install certifi==2024.8.30 charset-normalizer==3.4.0 idna==3.10 requests==2.32.3 urllib3==2.2.3\n\n    # 运行脚本\n    - name: Run deployment script\n      env:\n        # 设置环境变量，从GitHub Secrets和Variables获取\n        WXREAD_CURL_BASH: ${{ secrets.WXREAD_CURL_BASH }}  # 微信读书curl命令\n        PUSH_METHOD: ${{ secrets.PUSH_METHOD }}  # 推送方式\n        PUSHPLUS_TOKEN: ${{ secrets.PUSHPLUS_TOKEN }}  # PushPlus token\n        WXPUSHER_SPT: ${{ secrets.WXPUSHER_SPT }}  # WxPusher token\n        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}  # Telegram bot token\n        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}  # Telegram chat ID\n        READ_NUM: ${{ vars.READ_NUM }}  # 阅读次数，使用Repository Variables\n\n      run: |\n        python main.py  # 执行主脚本\n````\n\n````dockerfile path=Dockerfile mode=EDIT\n# Dockerfile - Docker容器配置文件\n# 功能：定义Docker镜像构建过程，用于在容器中运行微信读书自动阅读脚本\n# 作者：findmover\n# 版本：5.0\n\n# 使用Python 3.10精简版作为基础镜像\nFROM python:3.10-slim\n\n# 设置工作目录\nWORKDIR /app\n\n# 设置时区为中国时区，确保日志时间正确\nENV TZ=Asia/Shanghai\nRUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone\n\n# 安装 cron 定时任务工具\n# 更新apt源并安装cron，安装完成后清理apt缓存减小镜像体积\nRUN apt-get update &amp;&amp; apt-get install -y cron &amp;&amp; rm -rf /var/lib/apt/lists/*\nENV PATH=\&quot;/usr/local/bin:${PATH}\&quot;  # 确保Python\n````\n&quot;,&quot;workspace_file_chunks&quot;:[{&quot;char_start&quot;:&quot;0&quot;,&quot;char_end&quot;:&quot;776&quot;,&quot;blob_name&quot;:&quot;5b5e1a7c619328925ee56f999c0469ec7fd94507b9c11e5e5eb8b72565b88f47&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;Dockerfile&quot;}},{&quot;char_start&quot;:&quot;0&quot;,&quot;char_end&quot;:&quot;583&quot;,&quot;blob_name&quot;:&quot;0593b0df9fef649e16e3b424f3823d8c3add22e239099d4c5b6977050e88ecec&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;config.py&quot;}},{&quot;char_start&quot;:&quot;583&quot;,&quot;char_end&quot;:&quot;1047&quot;,&quot;blob_name&quot;:&quot;0593b0df9fef649e16e3b424f3823d8c3add22e239099d4c5b6977050e88ecec&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;config.py&quot;}},{&quot;char_start&quot;:&quot;1047&quot;,&quot;char_end&quot;:&quot;1524&quot;,&quot;blob_name&quot;:&quot;0593b0df9fef649e16e3b424f3823d8c3add22e239099d4c5b6977050e88ecec&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;config.py&quot;}},{&quot;char_start&quot;:&quot;1524&quot;,&quot;char_end&quot;:&quot;1869&quot;,&quot;blob_name&quot;:&quot;0593b0df9fef649e16e3b424f3823d8c3add22e239099d4c5b6977050e88ecec&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;config.py&quot;}},{&quot;char_start&quot;:&quot;1869&quot;,&quot;char_end&quot;:&quot;2324&quot;,&quot;blob_name&quot;:&quot;0593b0df9fef649e16e3b424f3823d8c3add22e239099d4c5b6977050e88ecec&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;config.py&quot;}},{&quot;char_start&quot;:&quot;2324&quot;,&quot;char_end&quot;:&quot;2810&quot;,&quot;blob_name&quot;:&quot;0593b0df9fef649e16e3b424f3823d8c3add22e239099d4c5b6977050e88ecec&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;config.py&quot;}},{&quot;char_start&quot;:&quot;2810&quot;,&quot;char_end&quot;:&quot;3644&quot;,&quot;blob_name&quot;:&quot;0593b0df9fef649e16e3b424f3823d8c3add22e239099d4c5b6977050e88ecec&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;config.py&quot;}},{&quot;char_start&quot;:&quot;3644&quot;,&quot;char_end&quot;:&quot;3881&quot;,&quot;blob_name&quot;:&quot;0593b0df9fef649e16e3b424f3823d8c3add22e239099d4c5b6977050e88ecec&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;config.py&quot;}},{&quot;char_start&quot;:&quot;0&quot;,&quot;char_end&quot;:&quot;646&quot;,&quot;blob_name&quot;:&quot;09cedc7333b97b881b3282a921e8a1083191be7480724aa7774357c6624e2dc0&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;main.py&quot;}},{&quot;char_start&quot;:&quot;646&quot;,&quot;char_end&quot;:&quot;1215&quot;,&quot;blob_name&quot;:&quot;09cedc7333b97b881b3282a921e8a1083191be7480724aa7774357c6624e2dc0&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;main.py&quot;}},{&quot;char_start&quot;:&quot;1215&quot;,&quot;char_end&quot;:&quot;1763&quot;,&quot;blob_name&quot;:&quot;09cedc7333b97b881b3282a921e8a1083191be7480724aa7774357c6624e2dc0&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;main.py&quot;}},{&quot;char_start&quot;:&quot;1763&quot;,&quot;char_end&quot;:&quot;2165&quot;,&quot;blob_name&quot;:&quot;09cedc7333b97b881b3282a921e8a1083191be7480724aa7774357c6624e2dc0&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;main.py&quot;}},{&quot;char_start&quot;:&quot;2165&quot;,&quot;char_end&quot;:&quot;2947&quot;,&quot;blob_name&quot;:&quot;09cedc7333b97b881b3282a921e8a1083191be7480724aa7774357c6624e2dc0&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;main.py&quot;}},{&quot;char_start&quot;:&quot;2947&quot;,&quot;char_end&quot;:&quot;3496&quot;,&quot;blob_name&quot;:&quot;09cedc7333b97b881b3282a921e8a1083191be7480724aa7774357c6624e2dc0&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;main.py&quot;}},{&quot;char_start&quot;:&quot;0&quot;,&quot;char_end&quot;:&quot;310&quot;,&quot;blob_name&quot;:&quot;f0bafbff69b3c07185a59268124b61c8534bc42d5e1728fed1e37b1a790fffa7&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;.github/workflows/deploy.yml&quot;}},{&quot;char_start&quot;:&quot;310&quot;,&quot;char_end&quot;:&quot;946&quot;,&quot;blob_name&quot;:&quot;f0bafbff69b3c07185a59268124b61c8534bc42d5e1728fed1e37b1a790fffa7&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;.github/workflows/deploy.yml&quot;}},{&quot;char_start&quot;:&quot;946&quot;,&quot;char_end&quot;:&quot;1425&quot;,&quot;blob_name&quot;:&quot;f0bafbff69b3c07185a59268124b61c8534bc42d5e1728fed1e37b1a790fffa7&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;.github/workflows/deploy.yml&quot;}},{&quot;char_start&quot;:&quot;0&quot;,&quot;char_end&quot;:&quot;734&quot;,&quot;blob_name&quot;:&quot;e49c4f24d89e8978e83c016039a35986e4d5bbba9161839857b9d8b03efa13cb&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;push.py&quot;}},{&quot;char_start&quot;:&quot;734&quot;,&quot;char_end&quot;:&quot;1752&quot;,&quot;blob_name&quot;:&quot;e49c4f24d89e8978e83c016039a35986e4d5bbba9161839857b9d8b03efa13cb&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;push.py&quot;}},{&quot;char_start&quot;:&quot;1752&quot;,&quot;char_end&quot;:&quot;2589&quot;,&quot;blob_name&quot;:&quot;e49c4f24d89e8978e83c016039a35986e4d5bbba9161839857b9d8b03efa13cb&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;push.py&quot;}},{&quot;char_start&quot;:&quot;2589&quot;,&quot;char_end&quot;:&quot;3324&quot;,&quot;blob_name&quot;:&quot;e49c4f24d89e8978e83c016039a35986e4d5bbba9161839857b9d8b03efa13cb&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;push.py&quot;}},{&quot;char_start&quot;:&quot;3324&quot;,&quot;char_end&quot;:&quot;3915&quot;,&quot;blob_name&quot;:&quot;e49c4f24d89e8978e83c016039a35986e4d5bbba9161839857b9d8b03efa13cb&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;push.py&quot;}},{&quot;char_start&quot;:&quot;0&quot;,&quot;char_end&quot;:&quot;758&quot;,&quot;blob_name&quot;:&quot;bbfc4f9d3687f11f24e0751daaf16f2b524ae5d0b3cc6eec01a88346a6d96ca3&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;README.md&quot;}},{&quot;char_start&quot;:&quot;758&quot;,&quot;char_end&quot;:&quot;1212&quot;,&quot;blob_name&quot;:&quot;bbfc4f9d3687f11f24e0751daaf16f2b524ae5d0b3cc6eec01a88346a6d96ca3&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;README.md&quot;}},{&quot;char_start&quot;:&quot;1212&quot;,&quot;char_end&quot;:&quot;1885&quot;,&quot;blob_name&quot;:&quot;bbfc4f9d3687f11f24e0751daaf16f2b524ae5d0b3cc6eec01a88346a6d96ca3&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;README.md&quot;}},{&quot;char_start&quot;:&quot;1885&quot;,&quot;char_end&quot;:&quot;2639&quot;,&quot;blob_name&quot;:&quot;bbfc4f9d3687f11f24e0751daaf16f2b524ae5d0b3cc6eec01a88346a6d96ca3&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;README.md&quot;}},{&quot;char_start&quot;:&quot;2639&quot;,&quot;char_end&quot;:&quot;3365&quot;,&quot;blob_name&quot;:&quot;bbfc4f9d3687f11f24e0751daaf16f2b524ae5d0b3cc6eec01a88346a6d96ca3&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;README.md&quot;}},{&quot;char_start&quot;:&quot;3365&quot;,&quot;char_end&quot;:&quot;3557&quot;,&quot;blob_name&quot;:&quot;bbfc4f9d3687f11f24e0751daaf16f2b524ae5d0b3cc6eec01a88346a6d96ca3&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;README.md&quot;}},{&quot;char_start&quot;:&quot;3557&quot;,&quot;char_end&quot;:&quot;4309&quot;,&quot;blob_name&quot;:&quot;bbfc4f9d3687f11f24e0751daaf16f2b524ae5d0b3cc6eec01a88346a6d96ca3&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;README.md&quot;}},{&quot;char_start&quot;:&quot;4309&quot;,&quot;char_end&quot;:&quot;4358&quot;,&quot;blob_name&quot;:&quot;bbfc4f9d3687f11f24e0751daaf16f2b524ae5d0b3cc6eec01a88346a6d96ca3&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;README.md&quot;}},{&quot;char_start&quot;:&quot;0&quot;,&quot;char_end&quot;:&quot;65&quot;,&quot;blob_name&quot;:&quot;c8a8c090a3061845fc4f889b1768d0fbdd0ff69303dde47aaa84e0888138f720&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;.gitignore&quot;}},{&quot;char_start&quot;:&quot;0&quot;,&quot;char_end&quot;:&quot;39&quot;,&quot;blob_name&quot;:&quot;5a5f4f85a0937b04443eb957206cd3248336b34b9c4a119c44e0a5adca444329&quot;,&quot;file&quot;:{&quot;repoRoot&quot;:&quot;&quot;,&quot;pathName&quot;:&quot;.vscode/settings.json&quot;}}]}],&quot;feedbackStates&quot;:{&quot;temp-fe-27066e9a-48f5-4d76-bbec-2d4edea28238&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;},&quot;temp-fe-fbf13bd4-bd1d-4251-853a-5626069d27ef&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;}},&quot;toolUseStates&quot;:{},&quot;draftExchange&quot;:{&quot;request_message&quot;:&quot;&quot;,&quot;rich_text_json_repr&quot;:{&quot;type&quot;:&quot;doc&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;paragraph&quot;}]},&quot;status&quot;:&quot;draft&quot;},&quot;requestIds&quot;:[],&quot;isPinned&quot;:false,&quot;isShareable&quot;:true,&quot;extraData&quot;:{&quot;hasDirtyEdits&quot;:false},&quot;personaType&quot;:0,&quot;rootTaskUuid&quot;:&quot;1d930681-5e21-426d-a742-5af2177d99dc&quot;},&quot;__NEW_AGENT__&quot;:{&quot;id&quot;:&quot;__NEW_AGENT__&quot;,&quot;createdAtIso&quot;:&quot;2025-07-09T16:01:54.401Z&quot;,&quot;lastInteractedAtIso&quot;:&quot;2025-07-09T16:01:54.414Z&quot;,&quot;chatHistory&quot;:[],&quot;feedbackStates&quot;:{},&quot;toolUseStates&quot;:{},&quot;draftExchange&quot;:{&quot;request_message&quot;:&quot;&quot;,&quot;rich_text_json_repr&quot;:{&quot;type&quot;:&quot;doc&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;paragraph&quot;}]},&quot;mentioned_items&quot;:[],&quot;status&quot;:&quot;draft&quot;},&quot;requestIds&quot;:[],&quot;isPinned&quot;:false,&quot;isShareable&quot;:false,&quot;extraData&quot;:{&quot;hasDirtyEdits&quot;:false,&quot;isAgentConversation&quot;:true,&quot;baselineTimestamp&quot;:0},&quot;personaType&quot;:0,&quot;rootTaskUuid&quot;:&quot;1df62bc7-47e4-4643-9776-0de25b2f5768&quot;}},&quot;agentExecutionMode&quot;:&quot;manual&quot;,&quot;isPanelCollapsed&quot;:true,&quot;displayedAnnouncements&quot;:[],&quot;sortConversationsBy&quot;:&quot;lastMessageTimestamp&quot;,&quot;sendMode&quot;:&quot;send&quot;}" />
      </map>
    </option>
  </component>
</project>